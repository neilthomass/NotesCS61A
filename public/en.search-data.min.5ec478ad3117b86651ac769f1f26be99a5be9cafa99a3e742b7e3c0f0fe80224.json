[{"id":0,"href":"/docs/week-12/calculator-language/","title":"Calculator Language","section":"Docs","content":" Calculator Language # Compiled vs Interpreted # High Level Languages (basically languages with a lot of abstraction from machine code - essentially 1s and 0s) are typically either compiled or interpreted.\nCompiling # When a program is compiled, the source code is directly translated to machine code right from the start - this code can then be distributed and run repeatedly.\nInterpreted # When a program is interpreted, the source code is run directly without first compiling it. This gives interpreted languages more overhead, but also makes it such that you remove the time needed for compilation.\nPhases of an Interpreter # In order to interpret source code, programs need to be written to understand said source code.\nA usual method is the following:\nSource Code -\u0026gt; Lexing -\u0026gt; Parsing -\u0026gt; Abstract Syntax Tree\nLexing and Parsing # The way to parse a scheme expression is to first collect the tokens of that expression (lexing), then turning it into a form readable by the language that it is to be interpreted by.\n(+ 1 (* 3 4)) -\u0026gt; Scheme Expression [\u0026#39;(\u0026#39;, \u0026#39;+\u0026#39;, \u0026#39;1\u0026#39;, \u0026#39;(\u0026#39;, \u0026#39;*\u0026#39;, \u0026#39;3\u0026#39;, \u0026#39;4\u0026#39;, \u0026#39;)\u0026#39;, \u0026#39;)\u0026#39;] -\u0026gt; Tokenized Pair(\u0026#39;+\u0026#39;, Pair(1, Pair(Pair([...])))) -\u0026gt; Parsed Lexical Analysis # Lexical Analysis is the process of turning an expression to its tokens. For example, the code block above shows lexical analysis of the phrase (+ 1 (* 3 4)) to our tokens ['(', '+', '1', '(', '*', '3', '4', ')', ')'].\nThis process is iterative, and processes lines one at a time.\nSyntactic Analysis # The syntactic analysis turns our tokens into a parsed form that is readable by programs. For example, the Pair class is used in the Python interpreted version of the calculator language.\nThis process is tree-recursive - it eventually returns a tree-like structure using linked lists and then processes multiple lines.\nPair Class # The Pair class is what\u0026rsquo;s used in CS61A to represent scheme lists.\ns = Pair(1, Pair(2, Pair(3, nil))) print(s) # (1 2 3) len(s) # 3 Calculator Language # Programming languages have the following features:\nSyntax: The statements and expressions in the code Semantics: The rules for evaluation within those statements and expressions When creating a new programming language, we need the following things:\nDocumentation (for how to use the program) Canonical Implementation (an interpreter/compiler for the language) Syntax # Our calculator expression will only have primitive expressions (numbers) and call expressions (+, -, *, /) with nothing else. This will give us the power to write mathematical expressions in scheme, then parse it using our parser.\nThe image above shows an example of an expression and the lexing and parsing that occurs from it.\nSemantics # The evaluation rules for a calculation expression is defined recursively.\nPrimitive: expresses to itself Call Expression: Evaluates to its operator applied on its operands. If we look at the expression tree above, whenever there\u0026rsquo;s a box, we need to evaluate the result from said box (which keeps going down until there are no more boxes to evaluate)\nEvaluation # This evaluation function computes the value of our expression. This function basically just looks at the data type then applies a different rule.\ncalc_eval # def calc_eval(exp): if isinstance(exp, (int, float)): return exp # if number, just give back a number elif isinstance(exp, Pair): arguments = exp.rest.map(calc_eval) # evaluate the rest of the arguments in the pair return calc_apply(exp.first, arguments) # apply the operator to the operands else: raise TypeError calc_apply # def calc_apply(operator, args): if operator == \u0026#39;+\u0026#39;: return reduce(add, args, 0) elif operator == \u0026#39;-\u0026#39;: ... elif operator == \u0026#39;*\u0026#39;: ... elif operator == \u0026#39;/\u0026#39;: ... else: raise TypeError "},{"id":1,"href":"/docs/week-12/macros-exceptions/","title":"Macros and Exceptions","section":"Docs","content":" Macros and Exceptions # Macros # In Scheme, everything is a list. For example, (quotient 1 2) can also be seen as a Scheme list with the elements quotient, 1, and 2. What the \u0026rsquo; operator lets us do in Scheme is create a list without evaluating certain options, then delay the evaluation until you need it later. For example:\n\u0026gt;\u0026gt;\u0026gt; (define lst (list \u0026#39;quotient 1 2)) lst \u0026gt;\u0026gt;\u0026gt; lst (quotient 1 2) \u0026gt;\u0026gt;\u0026gt; (eval lst) 0.5 \u0026gt;\u0026gt;\u0026gt; (eval (list \u0026#39;quotient 1 2)) 0.5 Quoting # There are two ways to quote an expression:\nQuoting Quasiquoting Quasiquotes are different because they allow certain elements to be unquoted using ,. This means that names can be bound directly:\n(define a 2) (define b 3) \u0026#39;(+ ,a b) ; (+ (unquote (a)) b) `(+ ,a b) ; (+ 2 b) When you call eval on the quasiquoted expression, it saves the value of a directly into the macro which can be very powerful.\nIf you try to call (eval '(+ ,a b)) you will get an error because , does not work unless it is in a quasiquote because Scheme.\nExceptions # Exceptions in Python are used to handle errors. In Python, you most likely would have seen quite a few exceptions (for example ZeroDivisionError, StopIteration, etc.) - there is a way to handle these exceptions.\ntry\u0026hellip;except # To handle an exception (which keeps the program running - it doesn\u0026rsquo;t make the program stop the moment an error appears), you can use Python\u0026rsquo;s built-in exception handling.\ntry: \u0026lt;body\u0026gt; except \u0026lt;exception\u0026gt; as \u0026lt;variable\u0026gt;: \u0026lt;body\u0026gt; [except \u0026lt;exception\u0026gt; as \u0026lt;variable\u0026gt; [...]] [else] First, the body in the try suite is executed first, then if an error is thrown that matches any \u0026lt;exception\u0026gt; that you put in, the body corresponding to that suite will be run with \u0026lt;variable\u0026gt; bound to the exception.\nExample # try: val = 10/0 except ZeroDivisionError as e: print(f\u0026#39;handling {type(e)}\u0026#39;) # handling \u0026lt;class \u0026#39;ZeroDivisionError\u0026#39;\u0026gt; val = 0 Example inside a function # def div(a, b): try: result = a / b except ZeroDivisionError: result = float(\u0026#39;inf\u0026#39;) return result div(10, 1) # 10 div(10, 0) # inf div(10, -1) # -10 What Would Python Do? # Taken from CS61A Fall 2021 Exceptions slides:\ndef invert(x): inverse = 1/x # Raises a ZeroDivisionError if x is 0 print(\u0026#39;Never printed if x is 0\u0026#39;) return inverse def invert_safe(x): try: return invert(x) except ZeroDivisionError as e: print(\u0026#39;ben\u0026#39;) return 0 invert_safe(1/0) # Error try: invert_safe(0) except ZeroDivisionError as e: print(\u0026#39;tao\u0026#39;) # ben # this is because the place where the error occurs is in the try except block where \u0026#39;ben\u0026#39; is printed Raising Exceptions # Assert Statements # assert statements that fail raise an exception of type AssertionError\nRaise Statement # You can raise any type of exception by using the raise statement:\nraise \u0026lt;expression\u0026gt; \u0026lt;exception\u0026gt; must evaluate to a subclass of BaseException (or an instance of one). Exceptions are constructed in the same way as do other classes:\nraise ZeroDivisionError(\u0026#34;lol wtf u doing\u0026#34;) "},{"id":2,"href":"/docs/week-11/scheme/","title":"Scheme","section":"Docs","content":" Scheme # Scheme is another programming language that CS61A can test. The reason why this is taught is not only because you make an interpreter for Scheme as your final CS61A project (where you write code in Python to essentially execute scheme code in Python - it\u0026rsquo;s really cool), but also because it\u0026rsquo;s essentially a practical way of showing that you\u0026rsquo;re able to quickly pick up other languages after you get comfortable with one.\nScheme isn\u0026rsquo;t really used that often in actual codebases, but it\u0026rsquo;s a pretty good method of teaching functional programming due to the restrictions it has in comparison to Python. (For example, Scheme doesn\u0026rsquo;t allow you to do any sort of iteration, and also lists can only be of the Linked list form, meaning that many of the programming problems are solved using recursion)\nScheme Expressions # Nearly everything in Scheme is executed the same - basically everything boils down to call expressions, even basic operations like + and /.\n(+ 1 2) ; 3 (/ 4 2) ; 2 (quotient 5 2) ; 2 (modulo 5 2) ; 1 A Python equivalent for the first line would be the following:\nfrom operator import add add(1, 2) # which is the same as 1 + 2 Notice how there\u0026rsquo;s consistent syntax? When you want to call something, you just wrap it in a set of parentheses, then you supply your operators and operands in the same order as call expressions in Python. The execution order of this call expression matches that of Python - it first looks at the operator and sees whether it can be a function, then evaluates the operands from left to right and after that is done, passes it into the operator.\n(/ (+ 2 2) 2) ; 2 You can also nest expressions in expressions.\nSpecial Forms # Everything in Scheme that doesn\u0026rsquo;t behave the same way as a call expression is a special form.\nif expression # (if \u0026lt;condition\u0026gt; \u0026lt;true-block\u0026gt; [\u0026lt;false-block\u0026gt;]) This will check whether \u0026lt;condition\u0026gt; is truthy (more on this later, it behaves differently to Python), then will execute \u0026lt;true-block\u0026gt; if it is, else will execute \u0026lt;false-block\u0026gt; if it\u0026rsquo;s provided.\nand/or # (and \u0026lt;e1\u0026gt; \u0026lt;e2\u0026gt; ... \u0026lt;en\u0026gt;) (or \u0026lt;e1\u0026gt; \u0026lt;e2\u0026gt; ... \u0026lt;en\u0026gt;) Behaves pretty much the same as Python and/or other than the truthy values.\ndefine - assignment in scheme # (define \u0026lt;symbol\u0026gt; \u0026lt;expression\u0026gt;) Assignment in Scheme (assigning an expression to a symbol)\n(define (\u0026lt;symbol\u0026gt; \u0026lt;parameters\u0026gt;) \u0026lt;body\u0026gt;) Assignment in Scheme but for functions instead (this is shorthand for making a lambda function then assigning that to a symbol - more on this later)\nDefine Form # (define x 2) ; x x ; 2 The code above will evaluate the expression 2, then binds that value to the name x. This name has to be a valid scheme symbol (so it can\u0026rsquo;t be integers for instance).\nDefine Procedure # (define (square x) (* x x)) The code above will make a lambda function that takes in a parameter x and when called, will multiply x by itself. This code is equivalent to the following:\n(define square (lambda (x) (* x x))) If Expression # In Scheme, everything that isn\u0026rsquo;t #f (which is the Scheme equivalent of False) is a truthy value. This is different to Python\u0026rsquo;s behaviour - remember to keep this in mind when you\u0026rsquo;re writing in scheme\nExample: Code that returns the length of non-empty lists, else returns 0 for empty lists.\n(define lst (list 1 2 3)) (if (null? lst) 0 (length lst)) ; null? and length are built-in procedures You can find all these built in procedures on CS61A\u0026rsquo;s official website.\nCond Expression # This special form allows for if \u0026hellip; elif \u0026hellip; else statements because the normal if expression that Scheme uses does not allow for multiple conditions. However, this cond expression allows for something similar to this to occur.\n(define x 2) (cond ((\u0026gt; x 2) \u0026#39;hi) ((\u0026gt; x 50) \u0026#39;ben) (else \u0026#39;not hi) ) ; not hi Lambda Expressions # lambda expressions evaluate to anonymous procedures (when not in a define expression). They are written (lambda ([param] ...) \u0026lt;body\u0026gt;). These lambdas can also be call expressions.\n(lambda (x) (* x 2)) ((lambda (x) (* x 2)) 4) ; 8 let # let in Scheme is pretty similar to define other than the scope that the variable is in. In essence, define when used will make a variable accessible in the global frame, but let will only make a variable that\u0026rsquo;s accessible in the function\u0026rsquo;s frame (Python\u0026rsquo;s default behvaiour).\nScheme Lists # All lists in Scheme are linked lists, similar to the Link class we were using earlier on in Python.\nLink(1, Link(2)) The Scheme equivalent to the linked list we made above is\n(cons 1 (cons 2 nil)) where nil is our Link.empty. This nil is required in Scheme when we use the cons expression.\nYou can also define lists in the following manner:\n(define lst_one (list 1 2 3)) lst_one ; (1 2 3) (define lst_two (list 1 (list 2 3) 4)) lst_two ; (1 (2 3) 4) (define lst_three \u0026#39;(1 2 3)) lst_three ; (1 2 3) (define lst_four \u0026#39;(1 (list 2 3) 4)) lst_four ; (1 (list 2 3) 4) - notice how this one doesn\u0026#39;t evaluate anything Accessing elements in our List # In Python:\nll = Link(1, Link(2)) ll.first # 1 ll.rest # Link(2) Scheme Equivalent:\n(define lst (list 1 2 3)) (car lst) ; 1 (cdr lst) ; (2 3) Names are weird - but you have to remember them. There is a historical reason for these chosen names, but I won\u0026rsquo;t cover them here because I don\u0026rsquo;t think it\u0026rsquo;s particularly too important to know at the moment. If you\u0026rsquo;re interested, take a look at this link.\nSymbolic Programming # Usually, symbols refer to values:\n(define a 1) (define b 2) (list a b) ; (1 2) However, we can use quotation to refer to the symbols directly:\n(define a 1) (define b 2) (list \u0026#39;a b) ; (a 2) This is shorthand for the quote form:\n(list (quote a) b) ; (a 2) The quote symbol basically says don\u0026rsquo;t touch anything typed afterwards - which is why \u0026lsquo;(1 2) will output a scheme list (because it\u0026rsquo;s represented that way normally)\nFunction Returns # There is no Scheme equivalent to return. In fact, the last statement in the body is what gets returned. This is similar to lambda functions in Python where the body is what gets returned, except in this case, the body can span multiple lines.\nHigher Order Functions # Say we wanted to make our own higher-order function that first takes in 1 argument as a number, then multiplies it with the value from the inner function.\nIn Python, we would write it like this:\n# with lambda lambda x: lambda y: x * y # with def statements def make_mul(x): def helper(y): return x * y return helper In Scheme, it pretty much looks the exact same:\n; with lambdas (lambda (x) (lambda (y) (* x y))) ; with define statements (define (make_mul x) (define (helper y) (* x y) ) helper ; this line over here is basically the same thing as saying return helper in Python ) It\u0026rsquo;s probably a lot nicer to use lambdas rather than named functions just because you don\u0026rsquo;t need to call the helper function in the end (similar to python where we don\u0026rsquo;t need to say return helper but can just use the lambda for that).\nThe reason why we can\u0026rsquo;t just define our function and then call it is because of the behaviour below:\n\u0026gt; (define (test x) (+ x x)) test \u0026gt; test (lambda (x) (+ x x)) As you can see, when we define a function, it returns the name of the function (as a \u0026lsquo;string\u0026rsquo;). Only after we call the function will we get a function representation of it.\nLet\u0026rsquo;s try to extend that to a higher-order function:\n\u0026gt; (define (test x)(define (ben y) (* x y))) test \u0026gt; (test 3) ben As you can see from the return value of calling (test 3), we get a \u0026lsquo;string\u0026rsquo; rather than the lambda function. This makes it such that we can\u0026rsquo;t call it directly. However, if we put:\n\u0026gt; (define (test x)(define (ben y) (* x y))ben) test \u0026gt; (test 3) (lambda (y) (* x y)) Now we are able to call this function directly.\n"}]