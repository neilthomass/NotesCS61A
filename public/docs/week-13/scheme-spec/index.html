<!doctype html><html lang=en dir=ltr><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="
  Scheme Specification
  #

This document describes the variant of Scheme used in CS61A, which is closest to R5RS but includes features from other versions. The specification is designed for ease of implementation and instruction.

  Overview and Terminology
  #


  Expressions and Environments
  #


Every expression evaluates to a value
Some expressions are self-evaluating (numbers, booleans, strings, nil)
Environments consist of frames (mappings from symbols to values)
Frames can have parent frames, creating a chain up to the global frame


  Atomic Expressions
  #


Numbers, booleans, strings, and nil are self-evaluating
Symbols evaluate to their bound values in the current environment


  Call Expressions
  #

Most Scheme expressions are combinations (parenthesized lists) evaluated as call expressions:"><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="http://localhost:1313/docs/week-13/scheme-spec/"><meta property="og:site_name" content="CS61A NT"><meta property="og:title" content="Scheme Specification"><meta property="og:description" content="Scheme Specification # This document describes the variant of Scheme used in CS61A, which is closest to R5RS but includes features from other versions. The specification is designed for ease of implementation and instruction.
Overview and Terminology # Expressions and Environments # Every expression evaluates to a value Some expressions are self-evaluating (numbers, booleans, strings, nil) Environments consist of frames (mappings from symbols to values) Frames can have parent frames, creating a chain up to the global frame Atomic Expressions # Numbers, booleans, strings, and nil are self-evaluating Symbols evaluate to their bound values in the current environment Call Expressions # Most Scheme expressions are combinations (parenthesized lists) evaluated as call expressions:"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="docs"><title>Scheme Specification | CS61A NT</title>
<link rel=icon href=/favicon.png><link rel=manifest href=/manifest.json><link rel=canonical href=http://localhost:1313/docs/week-13/scheme-spec/><link rel=stylesheet href=/book.min.a7616cf2799b58bddffce9438e31fdbfc6393687cfc0950a4a17cd1cce7e35f6.css integrity="sha256-p2Fs8nmbWL3f/OlDjjH9v8Y5NofPwJUKShfNHM5+NfY=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/en.search.min.9607d639059ea2596830e2eb9612e18d814493fc4a464e5b52a0c060069ea3ff.js integrity="sha256-lgfWOQWeolloMOLrlhLhjYFEk/xKRk5bUqDAYAaeo/8=" crossorigin=anonymous></script><script defer src=/sw.min.6f6f90fcb8eb1c49ec389838e6b801d0de19430b8e516902f8d75c3c8bd98739.js integrity="sha256-b2+Q/LjrHEnsOJg45rgB0N4ZQwuOUWkC+NdcPIvZhzk=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>CS61A NT</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul><li><a href target=_blank rel=noopener></a></li></ul><ul><li class=book-section-flat><span>Week 1</span><ul><li><a href=/docs/week-1/basics-of-python/>Basics of Python</a></li></ul></li><li class=book-section-flat><span>Week 2</span><ul><li><a href=/docs/week-2/control/>Control</a></li><li><a href=/docs/week-2/higher-order-functions/>Higher Order Functions</a></li><li><a href=/docs/week-2/environment-diagrams/>Environment Diagrams</a></li></ul></li><li class=book-section-flat><span>Week 3</span><ul><li><a href=/docs/week-3/decorators/>Decorators</a></li><li><a href=/docs/week-3/design/>Design</a></li></ul></li><li class=book-section-flat><span>Week 4</span><ul><li><a href=/docs/week-4/recursion/>Recursion</a></li><li><a href=/docs/week-4/tree-recursion/>Tree Recursion</a></li></ul></li><li class=book-section-flat><span>Week 5</span><ul><li><a href=/docs/week-5/containers/>Containers</a></li><li><a href=/docs/week-5/data-abstraction/>Data Abstraction</a></li><li><a href=/docs/week-5/sequences/>Sequences</a></li></ul></li><li class=book-section-flat><span>Week 6</span><ul><li><a href=/docs/week-6/mutability/>Mutability</a></li><li><a href=/docs/week-6/trees/>Trees</a></li></ul></li><li class=book-section-flat><span>Week 7</span><ul><li><a href=/docs/week-7/generators/>Generators</a></li><li><a href=/docs/week-7/iterators/>Iterators</a></li><li><a href=/docs/week-7/objects/>Objects</a></li></ul></li><li class=book-section-flat><span>Week 8</span><ul><li><a href=/docs/week-8/inheritance/>Inheritance</a></li><li><a href=/docs/week-8/recursive-data/>Recursive Data</a></li><li><a href=/docs/week-8/representation/>String Interpolation and Representation</a></li></ul></li><li class=book-section-flat><span>Week 9</span><ul><li><a href=/docs/week-9/efficiency/>Efficiency</a></li></ul></li><li class=book-section-flat><span>Week 10</span><ul><li><a href=/docs/week-10/break/>No Content This Week</a></li></ul></li><li class=book-section-flat><span>Week 11</span><ul><li><a href=/docs/week-11/scheme/>Scheme</a></li><li><a href=/docs/week-11/scheme-lists/>Scheme Lists</a></li></ul></li><li class=book-section-flat><span>Week 12</span><ul><li><a href=/docs/week-12/calculator-language/>Calculator Language</a></li><li><a href=/docs/week-12/interpreting-scheme/>Interpreting Scheme</a></li><li><a href=/docs/week-12/macros-exceptions/>Macros and Exceptions</a></li></ul></li><li><a href=/docs/week-13/sql-intro/>Introduction to SQL</a></li><li><a href=/docs/week-13/scheme-spec/ class=active>Scheme Specification</a></li></ul><ul><li><a href=https://linkedin.com/in/neiltthomas target=_blank rel=noopener>Linkedin</a></li><li><a href=neilthomas@berkeley.edu target=_blank rel=noopener>Email</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label><h3>Scheme Specification</h3><label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#scheme-specification>Scheme Specification</a><ul><li><a href=#overview-and-terminology>Overview and Terminology</a><ul><li><a href=#expressions-and-environments>Expressions and Environments</a></li><li><a href=#atomic-expressions>Atomic Expressions</a></li><li><a href=#call-expressions>Call Expressions</a></li><li><a href=#special-forms>Special Forms</a></li></ul></li><li><a href=#types-of-values>Types of Values</a><ul><li><a href=#numbers>Numbers</a></li><li><a href=#booleans>Booleans</a></li><li><a href=#symbols>Symbols</a></li><li><a href=#strings>Strings</a></li><li><a href=#pairs-and-lists>Pairs and Lists</a></li><li><a href=#procedures>Procedures</a></li><li><a href=#promises-and-streams>Promises and Streams</a></li></ul></li><li><a href=#special-forms-1>Special Forms</a><ul><li><a href=#define>define</a></li><li><a href=#if>if</a></li><li><a href=#cond>cond</a></li><li><a href=#let>let</a></li><li><a href=#lambda>lambda</a></li><li><a href=#quote-and-quasiquote>quote and quasiquote</a></li><li><a href=#define-macro>define-macro</a></li></ul></li><li><a href=#best-practices>Best Practices</a></li><li><a href=#common-pitfalls>Common Pitfalls</a></li><li><a href=#example-programs>Example Programs</a><ul><li><a href=#factorial>Factorial</a></li><li><a href=#map-implementation>Map Implementation</a></li><li><a href=#stream-of-fibonacci-numbers>Stream of Fibonacci Numbers</a></li></ul></li></ul></li></ul></nav></aside></header><article class="markdown book-article"><h1 id=scheme-specification>Scheme Specification
<a class=anchor href=#scheme-specification>#</a></h1><p>This document describes the variant of Scheme used in CS61A, which is closest to R5RS but includes features from other versions. The specification is designed for ease of implementation and instruction.</p><h2 id=overview-and-terminology>Overview and Terminology
<a class=anchor href=#overview-and-terminology>#</a></h2><h3 id=expressions-and-environments>Expressions and Environments
<a class=anchor href=#expressions-and-environments>#</a></h3><ul><li>Every expression evaluates to a value</li><li>Some expressions are self-evaluating (numbers, booleans, strings, nil)</li><li>Environments consist of frames (mappings from symbols to values)</li><li>Frames can have parent frames, creating a chain up to the global frame</li></ul><h3 id=atomic-expressions>Atomic Expressions
<a class=anchor href=#atomic-expressions>#</a></h3><ul><li>Numbers, booleans, strings, and nil are self-evaluating</li><li>Symbols evaluate to their bound values in the current environment</li></ul><h3 id=call-expressions>Call Expressions
<a class=anchor href=#call-expressions>#</a></h3><p>Most Scheme expressions are combinations (parenthesized lists) evaluated as call expressions:</p><ol><li>Evaluate the operator (first subexpression)</li><li>Evaluate the operands (remaining subexpressions)</li><li>Apply the procedure to the evaluated arguments</li></ol><h3 id=special-forms>Special Forms
<a class=anchor href=#special-forms>#</a></h3><p>Special forms are combinations that don&rsquo;t follow normal call expression evaluation:</p><ul><li>Identified by keywords as the first subexpression</li><li>Have their own evaluation procedures</li><li>Examples: <code>define</code>, <code>if</code>, <code>lambda</code>, etc.</li></ul><h2 id=types-of-values>Types of Values
<a class=anchor href=#types-of-values>#</a></h2><h3 id=numbers>Numbers
<a class=anchor href=#numbers>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span><span style=color:#75715e>; Built on Python&#39;s number types</span>
</span></span><span style=display:flex><span><span style=color:#75715e>; Supports large integers and floating points</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>123</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>3.14</span>
</span></span></code></pre></div><h3 id=booleans>Booleans
<a class=anchor href=#booleans>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span><span style=color:#75715e>; Two boolean values: #t and #f</span>
</span></span><span style=display:flex><span><span style=color:#75715e>; Can also use true and false</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>#t</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>#f</span>
</span></span></code></pre></div><h3 id=symbols>Symbols
<a class=anchor href=#symbols>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span><span style=color:#75715e>; Valid symbol characters: !$%&amp;*/:&lt;=&gt;?@^_~+-.</span>
</span></span><span style=display:flex><span><span style=color:#75715e>; Stored internally in lowercase</span>
</span></span><span style=display:flex><span>define
</span></span><span style=display:flex><span>lambda
</span></span></code></pre></div><h3 id=strings>Strings
<a class=anchor href=#strings>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span><span style=color:#75715e>; Immutable strings in double quotes</span>
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;Hello, World!&#34;</span>
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;CS61A&#34;</span>
</span></span></code></pre></div><h3 id=pairs-and-lists>Pairs and Lists
<a class=anchor href=#pairs-and-lists>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span><span style=color:#75715e>; Pairs have car (first) and cdr (rest)</span>
</span></span><span style=display:flex><span>(cons <span style=color:#ae81ff>1</span> <span style=color:#ae81ff>2</span>)        <span style=color:#75715e>; Creates a pair</span>
</span></span><span style=display:flex><span>(cons <span style=color:#ae81ff>1</span> nil)      <span style=color:#75715e>; Creates a list with one element</span>
</span></span><span style=display:flex><span>(cons <span style=color:#ae81ff>1</span> (cons <span style=color:#ae81ff>2</span> nil))  <span style=color:#75715e>; Creates a list with two elements</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&#39;</span>(<span style=color:#ae81ff>1</span> <span style=color:#ae81ff>2</span> <span style=color:#ae81ff>3</span>)          <span style=color:#75715e>; List literal</span>
</span></span></code></pre></div><h3 id=procedures>Procedures
<a class=anchor href=#procedures>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span><span style=color:#75715e>; First-class procedures</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>square</span> x) (* x x))
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>lambda </span>(<span style=color:#a6e22e>x</span>) (* x x))
</span></span></code></pre></div><h3 id=promises-and-streams>Promises and Streams
<a class=anchor href=#promises-and-streams>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span><span style=color:#75715e>; Delayed evaluation</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define </span>p (<span style=color:#66d9ef>delay </span>(+ <span style=color:#ae81ff>1</span> <span style=color:#ae81ff>2</span>)))
</span></span><span style=display:flex><span>(force p)         <span style=color:#75715e>; Evaluates the promise</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>; Streams are pairs with promises as cdr</span>
</span></span><span style=display:flex><span>(<span style=color:#a6e22e>cons-stream</span> <span style=color:#ae81ff>1</span> nil)
</span></span></code></pre></div><h2 id=special-forms-1>Special Forms
<a class=anchor href=#special-forms-1>#</a></h2><h3 id=define>define
<a class=anchor href=#define>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span><span style=color:#75715e>; Define a value</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define </span>x <span style=color:#ae81ff>5</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>; Define a procedure</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>square</span> x) (* x x))
</span></span></code></pre></div><h3 id=if>if
<a class=anchor href=#if>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span>(<span style=color:#66d9ef>if </span>(&lt; x <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>    (- x)
</span></span><span style=display:flex><span>    x)
</span></span></code></pre></div><h3 id=cond>cond
<a class=anchor href=#cond>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span>(<span style=color:#a6e22e>cond</span>
</span></span><span style=display:flex><span>    ((&lt; x <span style=color:#ae81ff>0</span>) <span style=color:#ae81ff>-1</span>)
</span></span><span style=display:flex><span>    ((&gt; x <span style=color:#ae81ff>0</span>) <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>    (<span style=color:#66d9ef>else </span><span style=color:#ae81ff>0</span>))
</span></span></code></pre></div><h3 id=let>let
<a class=anchor href=#let>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span>(<span style=color:#66d9ef>let </span>((<span style=color:#a6e22e>x</span> <span style=color:#ae81ff>5</span>)
</span></span><span style=display:flex><span>      (<span style=color:#a6e22e>y</span> <span style=color:#ae81ff>10</span>))
</span></span><span style=display:flex><span>    (+ x y))
</span></span></code></pre></div><h3 id=lambda>lambda
<a class=anchor href=#lambda>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span>(<span style=color:#66d9ef>lambda </span>(<span style=color:#a6e22e>x</span> y) (+ x y))
</span></span></code></pre></div><h3 id=quote-and-quasiquote>quote and quasiquote
<a class=anchor href=#quote-and-quasiquote>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span><span style=color:#f92672>&#39;</span>(<span style=color:#ae81ff>1</span> <span style=color:#ae81ff>2</span> <span style=color:#ae81ff>3</span>)          <span style=color:#75715e>; quote</span>
</span></span><span style=display:flex><span><span style=color:#f92672>`</span>(<span style=color:#ae81ff>1</span> <span style=color:#f92672>,</span>(+ <span style=color:#ae81ff>2</span> <span style=color:#ae81ff>3</span>) <span style=color:#ae81ff>4</span>)   <span style=color:#75715e>; quasiquote with unquote</span>
</span></span></code></pre></div><h3 id=define-macro>define-macro
<a class=anchor href=#define-macro>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span>(<span style=color:#a6e22e>define-macro</span> (<span style=color:#a6e22e>when</span> condition <span style=color:#f92672>.</span> body)
</span></span><span style=display:flex><span>    <span style=color:#f92672>`</span>(<span style=color:#66d9ef>if </span><span style=color:#f92672>,</span>condition (<span style=color:#66d9ef>begin </span><span style=color:#f92672>,@</span>body)))
</span></span></code></pre></div><h2 id=best-practices>Best Practices
<a class=anchor href=#best-practices>#</a></h2><ol><li><p><strong>Use meaningful names</strong></p><ul><li>Choose descriptive names for procedures and variables</li><li>Follow Scheme naming conventions</li></ul></li><li><p><strong>Proper list construction</strong></p><ul><li>Use <code>cons</code> for building lists</li><li>Use list literals with <code>'</code> for static lists</li></ul></li><li><p><strong>Error handling</strong></p><ul><li>Use <code>if</code> and <code>cond</code> for control flow</li><li>Handle edge cases explicitly</li></ul></li><li><p><strong>Procedure design</strong></p><ul><li>Keep procedures focused and small</li><li>Use helper procedures for complex tasks</li></ul></li><li><p><strong>Documentation</strong></p><ul><li>Comment complex procedures</li><li>Document assumptions and requirements</li></ul></li></ol><h2 id=common-pitfalls>Common Pitfalls
<a class=anchor href=#common-pitfalls>#</a></h2><ol><li><p><strong>Forgetting to quote lists</strong></p><ul><li><code>(1 2 3)</code> tries to call 1 as a procedure</li><li><code>'(1 2 3)</code> creates a list literal</li></ul></li><li><p><strong>Incorrect list structure</strong></p><ul><li>Lists must end with <code>nil</code></li><li>Use <code>cons</code> properly to build lists</li></ul></li><li><p><strong>Environment issues</strong></p><ul><li>Remember lexical scoping rules</li><li>Watch out for variable shadowing</li></ul></li><li><p><strong>Macro evaluation</strong></p><ul><li>Macros receive unevaluated expressions</li><li>Must return valid Scheme code</li></ul></li></ol><h2 id=example-programs>Example Programs
<a class=anchor href=#example-programs>#</a></h2><h3 id=factorial>Factorial
<a class=anchor href=#factorial>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>factorial</span> n)
</span></span><span style=display:flex><span>    (<span style=color:#66d9ef>if </span>(= n <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>        <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>        (* n (<span style=color:#a6e22e>factorial</span> (- n <span style=color:#ae81ff>1</span>)))))
</span></span></code></pre></div><h3 id=map-implementation>Map Implementation
<a class=anchor href=#map-implementation>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(map fn lst)
</span></span><span style=display:flex><span>    (<span style=color:#66d9ef>if </span>(null? lst)
</span></span><span style=display:flex><span>        nil
</span></span><span style=display:flex><span>        (cons (<span style=color:#a6e22e>fn</span> (car lst))
</span></span><span style=display:flex><span>              (map fn (cdr lst)))))
</span></span></code></pre></div><h3 id=stream-of-fibonacci-numbers>Stream of Fibonacci Numbers
<a class=anchor href=#stream-of-fibonacci-numbers>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>fib-stream</span>)
</span></span><span style=display:flex><span>    (<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>helper</span> a b)
</span></span><span style=display:flex><span>        (<span style=color:#a6e22e>cons-stream</span> a (<span style=color:#a6e22e>helper</span> b (+ a b))))
</span></span><span style=display:flex><span>    (<span style=color:#a6e22e>helper</span> <span style=color:#ae81ff>0</span> <span style=color:#ae81ff>1</span>))
</span></span></code></pre></div></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#scheme-specification>Scheme Specification</a><ul><li><a href=#overview-and-terminology>Overview and Terminology</a><ul><li><a href=#expressions-and-environments>Expressions and Environments</a></li><li><a href=#atomic-expressions>Atomic Expressions</a></li><li><a href=#call-expressions>Call Expressions</a></li><li><a href=#special-forms>Special Forms</a></li></ul></li><li><a href=#types-of-values>Types of Values</a><ul><li><a href=#numbers>Numbers</a></li><li><a href=#booleans>Booleans</a></li><li><a href=#symbols>Symbols</a></li><li><a href=#strings>Strings</a></li><li><a href=#pairs-and-lists>Pairs and Lists</a></li><li><a href=#procedures>Procedures</a></li><li><a href=#promises-and-streams>Promises and Streams</a></li></ul></li><li><a href=#special-forms-1>Special Forms</a><ul><li><a href=#define>define</a></li><li><a href=#if>if</a></li><li><a href=#cond>cond</a></li><li><a href=#let>let</a></li><li><a href=#lambda>lambda</a></li><li><a href=#quote-and-quasiquote>quote and quasiquote</a></li><li><a href=#define-macro>define-macro</a></li></ul></li><li><a href=#best-practices>Best Practices</a></li><li><a href=#common-pitfalls>Common Pitfalls</a></li><li><a href=#example-programs>Example Programs</a><ul><li><a href=#factorial>Factorial</a></li><li><a href=#map-implementation>Map Implementation</a></li><li><a href=#stream-of-fibonacci-numbers>Stream of Fibonacci Numbers</a></li></ul></li></ul></li></ul></nav></div></aside></main></body></html>