<!doctype html><html lang=en dir=ltr><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="
  Interpreting Scheme
  #

Interpreters keep going through an evaluate/apply cycle.

  Eval
  #


  Base Case
  #


Primitive Values


  Recursive Case
  #


Evaluate(operator, operands) of call expressions
Apply(procedure, arguments)


  Apply
  #


  Base Case
  #


Built in procedures


  Recursive Case
  #


User defined procedures


  Scheme Specific Traits
  #

Nearly everything in Scheme is a list (as mentioned countless times); additionally, nearly everything in scheme is a call expression where the operator is evaluated, then the operands are all evaluated, then these operands are applied to the operator."><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="http://localhost:1313/docs/week-12/interpreting-scheme/"><meta property="og:site_name" content="CS61A NT"><meta property="og:title" content="Interpreting Scheme"><meta property="og:description" content="Interpreting Scheme # Interpreters keep going through an evaluate/apply cycle.
Eval # Base Case # Primitive Values Recursive Case # Evaluate(operator, operands) of call expressions Apply(procedure, arguments) Apply # Base Case # Built in procedures Recursive Case # User defined procedures Scheme Specific Traits # Nearly everything in Scheme is a list (as mentioned countless times); additionally, nearly everything in scheme is a call expression where the operator is evaluated, then the operands are all evaluated, then these operands are applied to the operator."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="docs"><title>Interpreting Scheme | CS61A NT</title>
<link rel=icon href=/favicon.png><link rel=manifest href=/manifest.json><link rel=canonical href=http://localhost:1313/docs/week-12/interpreting-scheme/><link rel=stylesheet href=/book.min.a7616cf2799b58bddffce9438e31fdbfc6393687cfc0950a4a17cd1cce7e35f6.css integrity="sha256-p2Fs8nmbWL3f/OlDjjH9v8Y5NofPwJUKShfNHM5+NfY=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/en.search.min.c7ae51f584126b4a11733ecf708e4bea18be3f7cd29997867583234c3fbf7213.js integrity="sha256-x65R9YQSa0oRcz7PcI5L6hi+P3zSmZeGdYMjTD+/chM=" crossorigin=anonymous></script><script defer src=/sw.min.6f6f90fcb8eb1c49ec389838e6b801d0de19430b8e516902f8d75c3c8bd98739.js integrity="sha256-b2+Q/LjrHEnsOJg45rgB0N4ZQwuOUWkC+NdcPIvZhzk=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>CS61A NT</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul><li><a href target=_blank rel=noopener></a></li></ul><ul><li class=book-section-flat><span>Week 1</span><ul><li><a href=/docs/week-1/basics-of-python/>Basics of Python</a></li></ul></li><li class=book-section-flat><span>Week 2</span><ul><li><a href=/docs/week-2/control/>Control</a></li><li><a href=/docs/week-2/higher-order-functions/>Higher Order Functions</a></li><li><a href=/docs/week-2/environment-diagrams/>Environment Diagrams</a></li></ul></li><li class=book-section-flat><span>Week 3</span><ul><li><a href=/docs/week-3/decorators/>Decorators</a></li><li><a href=/docs/week-3/design/>Design</a></li></ul></li><li class=book-section-flat><span>Week 4</span><ul><li><a href=/docs/week-4/recursion/>Recursion</a></li><li><a href=/docs/week-4/tree-recursion/>Tree Recursion</a></li></ul></li><li class=book-section-flat><span>Week 5</span><ul><li><a href=/docs/week-5/containers/>Containers</a></li><li><a href=/docs/week-5/data-abstraction/>Data Abstraction</a></li><li><a href=/docs/week-5/sequences/>Sequences</a></li></ul></li><li class=book-section-flat><span>Week 6</span><ul><li><a href=/docs/week-6/mutability/>Mutability</a></li><li><a href=/docs/week-6/trees/>Trees</a></li></ul></li><li class=book-section-flat><span>Week 7</span><ul><li><a href=/docs/week-7/generators/>Generators</a></li><li><a href=/docs/week-7/iterators/>Iterators</a></li><li><a href=/docs/week-7/objects/>Objects</a></li></ul></li><li class=book-section-flat><span>Week 8</span><ul><li><a href=/docs/week-8/inheritance/>Inheritance</a></li><li><a href=/docs/week-8/recursive-data/>Recursive Data</a></li><li><a href=/docs/week-8/representation/>String Interpolation and Representation</a></li></ul></li><li class=book-section-flat><span>Week 9</span><ul><li><a href=/docs/week-9/efficiency/>Efficiency</a></li></ul></li><li class=book-section-flat><span>Week 10</span><ul><li><a href=/docs/week-10/break/>No Content This Week</a></li></ul></li><li class=book-section-flat><span>Week 11</span><ul><li><a href=/docs/week-11/scheme-lists/>Scheme Lists</a></li><li><a href=/docs/week-11/scheme/>Scheme Specification</a></li></ul></li><li class=book-section-flat><span>Week 12</span><ul><li><a href=/docs/week-12/calculator-language/>Calculator Language</a></li><li><a href=/docs/week-12/interpreting-scheme/ class=active>Interpreting Scheme</a></li><li><a href=/docs/week-12/macros-exceptions/>Macros and Exceptions</a></li></ul></li><li class=book-section-flat><span>Week 13</span><ul><li><a href=/docs/week-13/sql-intro/>SQL</a></li></ul></li></ul><ul><li><a href=https://linkedin.com/in/neiltthomas target=_blank rel=noopener>About Me</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label><h3>Interpreting Scheme</h3><label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#interpreting-scheme>Interpreting Scheme</a><ul><li><a href=#eval>Eval</a><ul><li><a href=#base-case>Base Case</a></li><li><a href=#recursive-case>Recursive Case</a></li></ul></li><li><a href=#apply>Apply</a><ul><li><a href=#base-case-1>Base Case</a></li><li><a href=#recursive-case-1>Recursive Case</a></li></ul></li><li><a href=#scheme-specific-traits>Scheme Specific Traits</a></li><li><a href=#evaluation>Evaluation</a></li><li><a href=#evaluating-combinations>Evaluating Combinations</a></li><li><a href=#symbols-and-functions>Symbols and Functions</a><ul><li><a href=#frames>Frames</a></li><li><a href=#define-expressions>Define Expressions</a></li><li><a href=#applying-user-defined-procedures>Applying User-Defined Procedures</a></li></ul></li></ul></li></ul></nav></aside></header><article class="markdown book-article"><h1 id=interpreting-scheme>Interpreting Scheme
<a class=anchor href=#interpreting-scheme>#</a></h1><p>Interpreters keep going through an evaluate/apply cycle.</p><h2 id=eval>Eval
<a class=anchor href=#eval>#</a></h2><h3 id=base-case>Base Case
<a class=anchor href=#base-case>#</a></h3><ul><li>Primitive Values</li></ul><h3 id=recursive-case>Recursive Case
<a class=anchor href=#recursive-case>#</a></h3><ul><li>Evaluate(operator, operands) of call expressions</li><li>Apply(procedure, arguments)</li></ul><h2 id=apply>Apply
<a class=anchor href=#apply>#</a></h2><h3 id=base-case-1>Base Case
<a class=anchor href=#base-case-1>#</a></h3><ul><li>Built in procedures</li></ul><h3 id=recursive-case-1>Recursive Case
<a class=anchor href=#recursive-case-1>#</a></h3><ul><li>User defined procedures</li></ul><h2 id=scheme-specific-traits>Scheme Specific Traits
<a class=anchor href=#scheme-specific-traits>#</a></h2><p>Nearly everything in Scheme is a list (as mentioned countless times); additionally, nearly everything in scheme is a call expression where the operator is evaluated, then the operands are all evaluated, then these operands are applied to the operator.</p><p>However, there are special forms that don&rsquo;t follow this evaluation procedure, which means that we need to create our own ruleset for these special forms.</p><h2 id=evaluation>Evaluation
<a class=anchor href=#evaluation>#</a></h2><p>Our <code>scheme_eval</code> function will choose its execution behaviour based on the expression form given to it:</p><ol><li>If a primitive is given (booleans, numbers, nil, etc), that primitive is just returned as a value itself</li><li>If there&rsquo;s a symbol in the expression, try to look up the value in the frame.</li><li>All other legal expressions are represented as Scheme lists (this could be normal call expressions or special forms) - these are called combinations</li></ol><h2 id=evaluating-combinations>Evaluating Combinations
<a class=anchor href=#evaluating-combinations>#</a></h2><p>We could have combinations that are call expressions and combinations that are special forms. How do we tell the difference between them such that we can choose how to evaluate them?</p><p>Let&rsquo;s try to look at examples to try and see the difference:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span>(+ <span style=color:#ae81ff>1</span> <span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define </span>x (+ <span style=color:#ae81ff>1</span> <span style=color:#ae81ff>2</span>))
</span></span><span style=display:flex><span>(* <span style=color:#ae81ff>1</span> <span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>if </span><span style=color:#66d9ef>#f</span> (/ <span style=color:#ae81ff>1</span> <span style=color:#ae81ff>0</span>) <span style=color:#ae81ff>0</span>)
</span></span></code></pre></div><p>Notice how the first &rsquo;token&rsquo; can be used to tell whether something is a call expression or a special form. If the first token (after the bracket) matches that of a known special form, we use a different evaluation procedure, else we just do the normal scheme special from evaluation procedure.</p><h2 id=symbols-and-functions>Symbols and Functions
<a class=anchor href=#symbols-and-functions>#</a></h2><h3 id=frames>Frames
<a class=anchor href=#frames>#</a></h3><p>Similarly to Python, Scheme variable looks at frames to find the values bound to symbols. In our interpreter, we will represent frames as Frame class instances. Each Frame object will have a lookup and define method. In this version we will not hold return values, but some other implementations may do that.</p><h3 id=define-expressions>Define Expressions
<a class=anchor href=#define-expressions>#</a></h3><p>Define would bind a symbol to a value to the first frame of the current environment that the code is in. If we need to define a procedure, what happens is that a lambda function is created, then that lambda function is the bound to the name.</p><h3 id=applying-user-defined-procedures>Applying User-Defined Procedures
<a class=anchor href=#applying-user-defined-procedures>#</a></h3><p>When applying user-defined procedures, we need to create a new frame where the arguments of the functions are defined, and then makes it such that the parent of the frame is just the env attribute of the procedure (you will see this in the Scheme Project code)</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#interpreting-scheme>Interpreting Scheme</a><ul><li><a href=#eval>Eval</a><ul><li><a href=#base-case>Base Case</a></li><li><a href=#recursive-case>Recursive Case</a></li></ul></li><li><a href=#apply>Apply</a><ul><li><a href=#base-case-1>Base Case</a></li><li><a href=#recursive-case-1>Recursive Case</a></li></ul></li><li><a href=#scheme-specific-traits>Scheme Specific Traits</a></li><li><a href=#evaluation>Evaluation</a></li><li><a href=#evaluating-combinations>Evaluating Combinations</a></li><li><a href=#symbols-and-functions>Symbols and Functions</a><ul><li><a href=#frames>Frames</a></li><li><a href=#define-expressions>Define Expressions</a></li><li><a href=#applying-user-defined-procedures>Applying User-Defined Procedures</a></li></ul></li></ul></li></ul></nav></div></aside></main></body></html>