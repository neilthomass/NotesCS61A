<!doctype html><html lang=en dir=ltr><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="
  Calculator Language
  #


  Compiled vs Interpreted
  #

High Level Languages (basically languages with a lot of abstraction from machine code - essentially 1s and 0s) are typically either compiled or interpreted.

  Compiling
  #

When a program is compiled, the source code is directly translated to machine code right from the start - this code can then be distributed and run repeatedly.

  Interpreted
  #

When a program is interpreted, the source code is run directly without first compiling it. This gives interpreted languages more overhead, but also makes it such that you remove the time needed for compilation."><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="http://localhost:1313/docs/week-12/calculator-language/"><meta property="og:site_name" content="CS61A NT"><meta property="og:title" content="Calculator Language"><meta property="og:description" content="Calculator Language # Compiled vs Interpreted # High Level Languages (basically languages with a lot of abstraction from machine code - essentially 1s and 0s) are typically either compiled or interpreted.
Compiling # When a program is compiled, the source code is directly translated to machine code right from the start - this code can then be distributed and run repeatedly.
Interpreted # When a program is interpreted, the source code is run directly without first compiling it. This gives interpreted languages more overhead, but also makes it such that you remove the time needed for compilation."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="docs"><title>Calculator Language | CS61A NT</title>
<link rel=icon href=/favicon.png><link rel=manifest href=/manifest.json><link rel=canonical href=http://localhost:1313/docs/week-12/calculator-language/><link rel=stylesheet href=/book.min.a7616cf2799b58bddffce9438e31fdbfc6393687cfc0950a4a17cd1cce7e35f6.css integrity="sha256-p2Fs8nmbWL3f/OlDjjH9v8Y5NofPwJUKShfNHM5+NfY=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/en.search.min.c7ae51f584126b4a11733ecf708e4bea18be3f7cd29997867583234c3fbf7213.js integrity="sha256-x65R9YQSa0oRcz7PcI5L6hi+P3zSmZeGdYMjTD+/chM=" crossorigin=anonymous></script><script defer src=/sw.min.6f6f90fcb8eb1c49ec389838e6b801d0de19430b8e516902f8d75c3c8bd98739.js integrity="sha256-b2+Q/LjrHEnsOJg45rgB0N4ZQwuOUWkC+NdcPIvZhzk=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>CS61A NT</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul><li><a href target=_blank rel=noopener></a></li></ul><ul><li class=book-section-flat><span>Week 1</span><ul><li><a href=/docs/week-1/basics-of-python/>Basics of Python</a></li></ul></li><li class=book-section-flat><span>Week 2</span><ul><li><a href=/docs/week-2/control/>Control</a></li><li><a href=/docs/week-2/higher-order-functions/>Higher Order Functions</a></li><li><a href=/docs/week-2/environment-diagrams/>Environment Diagrams</a></li></ul></li><li class=book-section-flat><span>Week 3</span><ul><li><a href=/docs/week-3/decorators/>Decorators</a></li><li><a href=/docs/week-3/design/>Design</a></li></ul></li><li class=book-section-flat><span>Week 4</span><ul><li><a href=/docs/week-4/recursion/>Recursion</a></li><li><a href=/docs/week-4/tree-recursion/>Tree Recursion</a></li></ul></li><li class=book-section-flat><span>Week 5</span><ul><li><a href=/docs/week-5/containers/>Containers</a></li><li><a href=/docs/week-5/data-abstraction/>Data Abstraction</a></li><li><a href=/docs/week-5/sequences/>Sequences</a></li></ul></li><li class=book-section-flat><span>Week 6</span><ul><li><a href=/docs/week-6/mutability/>Mutability</a></li><li><a href=/docs/week-6/trees/>Trees</a></li></ul></li><li class=book-section-flat><span>Week 7</span><ul><li><a href=/docs/week-7/generators/>Generators</a></li><li><a href=/docs/week-7/iterators/>Iterators</a></li><li><a href=/docs/week-7/objects/>Objects</a></li></ul></li><li class=book-section-flat><span>Week 8</span><ul><li><a href=/docs/week-8/inheritance/>Inheritance</a></li><li><a href=/docs/week-8/recursive-data/>Recursive Data</a></li><li><a href=/docs/week-8/representation/>String Interpolation and Representation</a></li></ul></li><li class=book-section-flat><span>Week 9</span><ul><li><a href=/docs/week-9/efficiency/>Efficiency</a></li></ul></li><li class=book-section-flat><span>Week 10</span><ul><li><a href=/docs/week-10/break/>No Content This Week</a></li></ul></li><li class=book-section-flat><span>Week 11</span><ul><li><a href=/docs/week-11/scheme-lists/>Scheme Lists</a></li><li><a href=/docs/week-11/scheme/>Scheme Specification</a></li></ul></li><li class=book-section-flat><span>Week 12</span><ul><li><a href=/docs/week-12/calculator-language/ class=active>Calculator Language</a></li><li><a href=/docs/week-12/interpreting-scheme/>Interpreting Scheme</a></li><li><a href=/docs/week-12/macros-exceptions/>Macros and Exceptions</a></li></ul></li><li class=book-section-flat><span>Week 13</span><ul><li><a href=/docs/week-13/sql-intro/>SQL</a></li></ul></li></ul><ul><li><a href=https://linkedin.com/in/neiltthomas target=_blank rel=noopener>About Me</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label><h3>Calculator Language</h3><label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#calculator-language>Calculator Language</a><ul><li><a href=#compiled-vs-interpreted>Compiled vs Interpreted</a><ul><li><a href=#compiling>Compiling</a></li><li><a href=#interpreted>Interpreted</a></li></ul></li><li><a href=#phases-of-an-interpreter>Phases of an Interpreter</a><ul><li><a href=#lexing-and-parsing>Lexing and Parsing</a></li><li><a href=#lexical-analysis>Lexical Analysis</a></li><li><a href=#syntactic-analysis>Syntactic Analysis</a></li><li><a href=#pair-class>Pair Class</a></li></ul></li><li><a href=#calculator-language-1>Calculator Language</a><ul><li><a href=#syntax>Syntax</a></li><li><a href=#semantics>Semantics</a></li><li><a href=#evaluation>Evaluation</a></li></ul></li></ul></li></ul></nav></aside></header><article class="markdown book-article"><h1 id=calculator-language>Calculator Language
<a class=anchor href=#calculator-language>#</a></h1><h2 id=compiled-vs-interpreted>Compiled vs Interpreted
<a class=anchor href=#compiled-vs-interpreted>#</a></h2><p>High Level Languages (basically languages with a lot of abstraction from machine code - essentially 1s and 0s) are typically either compiled or interpreted.</p><h3 id=compiling>Compiling
<a class=anchor href=#compiling>#</a></h3><p>When a program is compiled, the source code is directly translated to machine code right from the start - this code can then be distributed and run repeatedly.</p><h3 id=interpreted>Interpreted
<a class=anchor href=#interpreted>#</a></h3><p>When a program is interpreted, the source code is run directly without first compiling it. This gives interpreted languages more overhead, but also makes it such that you remove the time needed for compilation.</p><h2 id=phases-of-an-interpreter>Phases of an Interpreter
<a class=anchor href=#phases-of-an-interpreter>#</a></h2><p>In order to interpret source code, programs need to be written to understand said source code.</p><p>A usual method is the following:</p><p>Source Code -> Lexing -> Parsing -> Abstract Syntax Tree</p><h3 id=lexing-and-parsing>Lexing and Parsing
<a class=anchor href=#lexing-and-parsing>#</a></h3><p>The way to parse a scheme expression is to first collect the tokens of that expression (lexing), then turning it into a form readable by the language that it is to be interpreted by.</p><pre tabindex=0><code>(+ 1 (* 3 4)) -&gt; Scheme Expression
[&#39;(&#39;, &#39;+&#39;, &#39;1&#39;, &#39;(&#39;, &#39;*&#39;, &#39;3&#39;, &#39;4&#39;, &#39;)&#39;, &#39;)&#39;] -&gt; Tokenized
Pair(&#39;+&#39;, Pair(1, Pair(Pair([...])))) -&gt; Parsed
</code></pre><h3 id=lexical-analysis>Lexical Analysis
<a class=anchor href=#lexical-analysis>#</a></h3><p>Lexical Analysis is the process of turning an expression to its tokens. For example, the code block above shows lexical analysis of the phrase <code>(+ 1 (* 3 4))</code> to our tokens <code>['(', '+', '1', '(', '*', '3', '4', ')', ')']</code>.</p><p>This process is iterative, and processes lines one at a time.</p><h3 id=syntactic-analysis>Syntactic Analysis
<a class=anchor href=#syntactic-analysis>#</a></h3><p>The syntactic analysis turns our tokens into a parsed form that is readable by programs. For example, the Pair class is used in the Python interpreted version of the calculator language.</p><p>This process is tree-recursive - it eventually returns a tree-like structure using linked lists and then processes multiple lines.</p><h3 id=pair-class>Pair Class
<a class=anchor href=#pair-class>#</a></h3><p>The Pair class is what&rsquo;s used in CS61A to represent scheme lists.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>s <span style=color:#f92672>=</span> Pair(<span style=color:#ae81ff>1</span>, Pair(<span style=color:#ae81ff>2</span>, Pair(<span style=color:#ae81ff>3</span>, nil)))
</span></span><span style=display:flex><span>print(s)  <span style=color:#75715e># (1 2 3)</span>
</span></span><span style=display:flex><span>len(s)    <span style=color:#75715e># 3</span>
</span></span></code></pre></div><h2 id=calculator-language-1>Calculator Language
<a class=anchor href=#calculator-language-1>#</a></h2><p>Programming languages have the following features:</p><ul><li>Syntax: The statements and expressions in the code</li><li>Semantics: The rules for evaluation within those statements and expressions</li></ul><p>When creating a new programming language, we need the following things:</p><ol><li>Documentation (for how to use the program)</li><li>Canonical Implementation (an interpreter/compiler for the language)</li></ol><h3 id=syntax>Syntax
<a class=anchor href=#syntax>#</a></h3><p>Our calculator expression will only have primitive expressions (numbers) and call expressions (+, -, *, /) with nothing else. This will give us the power to write mathematical expressions in scheme, then parse it using our parser.</p><p>The image above shows an example of an expression and the lexing and parsing that occurs from it.</p><h3 id=semantics>Semantics
<a class=anchor href=#semantics>#</a></h3><p>The evaluation rules for a calculation expression is defined recursively.</p><ul><li>Primitive: expresses to itself</li><li>Call Expression: Evaluates to its operator applied on its operands.</li></ul><p>If we look at the expression tree above, whenever there&rsquo;s a box, we need to evaluate the result from said box (which keeps going down until there are no more boxes to evaluate)</p><h3 id=evaluation>Evaluation
<a class=anchor href=#evaluation>#</a></h3><p>This evaluation function computes the value of our expression. This function basically just looks at the data type then applies a different rule.</p><h4 id=calc_eval>calc_eval
<a class=anchor href=#calc_eval>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>calc_eval</span>(exp):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> isinstance(exp, (int, float)):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> exp <span style=color:#75715e># if number, just give back a number</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>elif</span> isinstance(exp, Pair):
</span></span><span style=display:flex><span>        arguments <span style=color:#f92672>=</span> exp<span style=color:#f92672>.</span>rest<span style=color:#f92672>.</span>map(calc_eval) <span style=color:#75715e># evaluate the rest of the arguments in the pair</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> calc_apply(exp<span style=color:#f92672>.</span>first, arguments) <span style=color:#75715e># apply the operator to the operands</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>raise</span> <span style=color:#a6e22e>TypeError</span>
</span></span></code></pre></div><h4 id=calc_apply>calc_apply
<a class=anchor href=#calc_apply>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>calc_apply</span>(operator, args):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> operator <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;+&#39;</span>:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> reduce(add, args, <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>elif</span> operator <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;-&#39;</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>elif</span> operator <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;*&#39;</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>elif</span> operator <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;/&#39;</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>raise</span> <span style=color:#a6e22e>TypeError</span>
</span></span></code></pre></div></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#calculator-language>Calculator Language</a><ul><li><a href=#compiled-vs-interpreted>Compiled vs Interpreted</a><ul><li><a href=#compiling>Compiling</a></li><li><a href=#interpreted>Interpreted</a></li></ul></li><li><a href=#phases-of-an-interpreter>Phases of an Interpreter</a><ul><li><a href=#lexing-and-parsing>Lexing and Parsing</a></li><li><a href=#lexical-analysis>Lexical Analysis</a></li><li><a href=#syntactic-analysis>Syntactic Analysis</a></li><li><a href=#pair-class>Pair Class</a></li></ul></li><li><a href=#calculator-language-1>Calculator Language</a><ul><li><a href=#syntax>Syntax</a></li><li><a href=#semantics>Semantics</a></li><li><a href=#evaluation>Evaluation</a></li></ul></li></ul></li></ul></nav></div></aside></main></body></html>