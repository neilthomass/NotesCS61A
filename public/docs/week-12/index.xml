<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>CS61A NT</title><link>http://localhost:1313/docs/week-12/</link><description>Recent content on CS61A NT</description><generator>Hugo</generator><language>en</language><atom:link href="http://localhost:1313/docs/week-12/index.xml" rel="self" type="application/rss+xml"/><item><title>Calculator Language</title><link>http://localhost:1313/docs/week-12/calculator-language/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/docs/week-12/calculator-language/</guid><description>&lt;h1 id="calculator-language">
 Calculator Language
 &lt;a class="anchor" href="#calculator-language">#&lt;/a>
&lt;/h1>
&lt;h2 id="compiled-vs-interpreted">
 Compiled vs Interpreted
 &lt;a class="anchor" href="#compiled-vs-interpreted">#&lt;/a>
&lt;/h2>
&lt;p>High Level Languages (basically languages with a lot of abstraction from machine code - essentially 1s and 0s) are typically either compiled or interpreted.&lt;/p>
&lt;h3 id="compiling">
 Compiling
 &lt;a class="anchor" href="#compiling">#&lt;/a>
&lt;/h3>
&lt;p>When a program is compiled, the source code is directly translated to machine code right from the start - this code can then be distributed and run repeatedly.&lt;/p>
&lt;h3 id="interpreted">
 Interpreted
 &lt;a class="anchor" href="#interpreted">#&lt;/a>
&lt;/h3>
&lt;p>When a program is interpreted, the source code is run directly without first compiling it. This gives interpreted languages more overhead, but also makes it such that you remove the time needed for compilation.&lt;/p></description></item><item><title>Interpreting Scheme</title><link>http://localhost:1313/docs/week-12/interpreting-scheme/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/docs/week-12/interpreting-scheme/</guid><description>&lt;h1 id="interpreting-scheme">
 Interpreting Scheme
 &lt;a class="anchor" href="#interpreting-scheme">#&lt;/a>
&lt;/h1>
&lt;p>Interpreters keep going through an evaluate/apply cycle.&lt;/p>
&lt;h2 id="eval">
 Eval
 &lt;a class="anchor" href="#eval">#&lt;/a>
&lt;/h2>
&lt;h3 id="base-case">
 Base Case
 &lt;a class="anchor" href="#base-case">#&lt;/a>
&lt;/h3>
&lt;ul>
&lt;li>Primitive Values&lt;/li>
&lt;/ul>
&lt;h3 id="recursive-case">
 Recursive Case
 &lt;a class="anchor" href="#recursive-case">#&lt;/a>
&lt;/h3>
&lt;ul>
&lt;li>Evaluate(operator, operands) of call expressions&lt;/li>
&lt;li>Apply(procedure, arguments)&lt;/li>
&lt;/ul>
&lt;h2 id="apply">
 Apply
 &lt;a class="anchor" href="#apply">#&lt;/a>
&lt;/h2>
&lt;h3 id="base-case-1">
 Base Case
 &lt;a class="anchor" href="#base-case-1">#&lt;/a>
&lt;/h3>
&lt;ul>
&lt;li>Built in procedures&lt;/li>
&lt;/ul>
&lt;h3 id="recursive-case-1">
 Recursive Case
 &lt;a class="anchor" href="#recursive-case-1">#&lt;/a>
&lt;/h3>
&lt;ul>
&lt;li>User defined procedures&lt;/li>
&lt;/ul>
&lt;h2 id="scheme-specific-traits">
 Scheme Specific Traits
 &lt;a class="anchor" href="#scheme-specific-traits">#&lt;/a>
&lt;/h2>
&lt;p>Nearly everything in Scheme is a list (as mentioned countless times); additionally, nearly everything in scheme is a call expression where the operator is evaluated, then the operands are all evaluated, then these operands are applied to the operator.&lt;/p></description></item><item><title>Macros and Exceptions</title><link>http://localhost:1313/docs/week-12/macros-exceptions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/docs/week-12/macros-exceptions/</guid><description>&lt;h1 id="macros-and-exceptions">
 Macros and Exceptions
 &lt;a class="anchor" href="#macros-and-exceptions">#&lt;/a>
&lt;/h1>
&lt;h2 id="macros">
 Macros
 &lt;a class="anchor" href="#macros">#&lt;/a>
&lt;/h2>
&lt;p>In Scheme, everything is a list. For example, &lt;code>(quotient 1 2)&lt;/code> can also be seen as a Scheme list with the elements quotient, 1, and 2. What the &amp;rsquo; operator lets us do in Scheme is create a list without evaluating certain options, then delay the evaluation until you need it later. For example:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-scheme" data-lang="scheme">&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; (&lt;span style="color:#66d9ef">define &lt;/span>lst (list &lt;span style="color:#e6db74">&amp;#39;quotient&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>lst
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; lst
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>(quotient &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; (eval lst)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">0.5&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; (eval (list &lt;span style="color:#e6db74">&amp;#39;quotient&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">0.5&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="quoting">
 Quoting
 &lt;a class="anchor" href="#quoting">#&lt;/a>
&lt;/h3>
&lt;p>There are two ways to quote an expression:&lt;/p></description></item></channel></rss>