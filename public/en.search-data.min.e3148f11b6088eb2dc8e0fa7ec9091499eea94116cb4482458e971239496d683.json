[{"id":0,"href":"/cs61a/docs/week-2/control/","title":"Control","section":"Week 2","content":" Control # Side Effects # Side effects occur in functions when the function alters the global environment in some form. This could be in the form of altering a variable in the global scope, or using a print statement inside a function. One easy way to tell if a function contains side effects is that if a function acts like a mathematical function, it has no side effects.\nA Mathematical function f(x) takes inputs and always provides the same outputs, without doing anything else. As a result, one input will never have two or more different outputs. If a programming function has the same property where certain outputs always provide the same inputs without doing anything else, it has no side effects.\nExample With No Side Effects # def no_side_effects(x): # Squares x return x*x no_side_effects(2) # \u0026gt;\u0026gt;\u0026gt; 4 no_side_effects(2) # \u0026gt;\u0026gt;\u0026gt; 4 In this example, every input will always map to the same output as the function does not do anything other than provide an output given an input.\nExample With Side Effects # ben = 1 def with_side_effects(x): return x*ben with_side_effects(2) # \u0026gt;\u0026gt;\u0026gt; 2 ben = 2 with_side_effects(2) # \u0026gt;\u0026gt;\u0026gt; 4 While this example is not going to be used in a practical setting, it serves as a good example of what a side effect is. As you can see, even though we called the function with_side_effects twice with the same input, the output was different, which goes against the definition of a mathematical function. As a result, there is a side effect in that function.\nA side note:\nWhile the print function does not change the value of any variables, it does cause a side effect by outputting something to the console, which does go against how a mathematical function works. However, while side effects are usually better to avoid where possible, print could sometimes be useful for debugging.\nAn example of a side effect that can\u0026rsquo;t be avoided is writing to a file - this is necessary at times.\nA function without side effects is also known as a pure function, while a function with side effects is also known as an impure function.\nThe \u0026lsquo;None\u0026rsquo; Value # In Python, any function that does not return a value will return None, which when printed will render None to the console, and when called, will not render anything in the console.\nFor example:\ndef no_return(x): x = 1 print(no_return(2)) # \u0026gt;\u0026gt;\u0026gt; None Note that the print() function has no return value, and thus will return None when called.\nNested Print Statements # A nested print function is somewhat weird, but worth it to learn.\nTake this for example, what do you think will get outputted to the console? Try to think for yourself before opening the answer box below.\nprint(print(1)) For a harder example, try this one:\nprint(print(\u0026#34;x\u0026#34;), print(\u0026#34;y\u0026#34;)) Default Arguments # In the function signature, one of the inputs can have a default value. This is useful in situations where there is a most likely case for a function, but where it still makes sense for users to have some control.\nFor example, the default round() function in Python takes in 1 required parameter, with 1 optional parameter (which defaults to 0).\nround(2.5342) # \u0026gt;\u0026gt;\u0026gt; 3 round(2.5342, 2) # \u0026gt;\u0026gt;\u0026gt; 2.53 You can build your own function with default arguments by simply specifying it in the header.\nFor example:\ndef ben(baron, box=\u0026#34;tao\u0026#34;): return baron + box ben(\u0026#34;baron\u0026#34;) # \u0026gt;\u0026gt;\u0026gt; \u0026#39;barontao\u0026#39; ben(\u0026#34;baron\u0026#34;, \u0026#34;hej\u0026#34;) # \u0026gt;\u0026gt;\u0026gt; \u0026#39;baronhej\u0026#39; Without the second optional parameter hej, the function defaulted to the value tao.\nIf you have multiple default arguments, you can also override them in this way:\ndef ben(baron, box=\u0026#34;tao\u0026#34;, foo=\u0026#34;baz\u0026#34;): return baron + box + foo ben(\u0026#34;baron\u0026#34;, foo=\u0026#34;yu\u0026#34;) # \u0026gt;\u0026gt;\u0026gt; barontaoyu ben(\u0026#34;baron\u0026#34;, box=\u0026#34;yu\u0026#34;) # \u0026gt;\u0026gt;\u0026gt; baronyubaz Multiple Return Values # One aspect of Python uncommon in other languages is the allowed use of multiple return values in functions. This can be done in a function by using multiple return values separated by a comma.\nAny code that calls the function can either store it in a variable as a tuple (more on this later) or can be unpacked. For example:\ndef return_two_values(): return 1, 2 return_two_values() # \u0026gt;\u0026gt;\u0026gt; (1, 2) in tuple form a, b = return_two_values() a # \u0026gt;\u0026gt;\u0026gt; 1 b # \u0026gt;\u0026gt;\u0026gt; 2 Multiple Variable Assignment # The values on the right side are evaluated first before being assigned, so you can swap the values of two variables in one line by simply doing the following:\nx, y = y, x Boolean # A Boolean is a value that is either True or False, and is used frequently in many applications. For example, your mobile device would likely have a Boolean variable that stores whether your WiFi, flashlight, bluetooth etc. is turned on.\nAn expression can evaluate to a Boolean. For example:\npassed_class = grade \u0026gt;= 70 # Will evaluate either true or false depending on the condition take_shower = (not eecs_major) or did_sports Comparison Operators # Operator Meaning == Equality != Inequality \u0026gt; Greater Than \u0026lt; Less Than \u0026gt;= Greater Than or Equals \u0026lt;= Less Than or Equals Checking for Equality: It is a common mistake to use = instead of == to check for equality. Please remember that = is for assigning a variable and cannot be used for checking for equality in a conditional statement. Python will throw a syntax error, but other languages may not, so not mixing these up is a good habit to get used to.\nLogical Operators # Operator Meaning and Evaluates to True if both values are True or Evaluates to True if any of the values are True not Evaluates to True if the value is False, else evaluates to True Execution rules of logical operators # The statements are evaluated from left to right, but sometimes, these statements do not all need to be evaluated.\nand statement procedure:\nEvaluate the left statement. If it evaluates to a False value x, the expression evaluates to x. Else, the expression evaluates to the value of the expression on the right. or statement procedure:\nEvaluate the left statement. If it evaluates to a True value x the expression evaluates to x. Else, the expression evaluates to the value of the expression on the right. This procedure functions using just Booleans, but strange things occur when you use other values instead.\nFor example:\n5 and 2 # \u0026gt;\u0026gt;\u0026gt; 2 5 or 2 # \u0026gt;\u0026gt;\u0026gt; 5 not 5 # \u0026gt;\u0026gt;\u0026gt; False not 0 # \u0026gt;\u0026gt;\u0026gt; True 0 and False # \u0026gt;\u0026gt;\u0026gt; 0 For the and and or operators, numbers were returned rather than Booleans due to the procedure of evaluating these logical statements.\nThere is an order of operations for Booleans (not → and → or), but generally, use brackets to make your statements clearer.\nYou can use these expressions in functions as the return value. For example:\ndef boolean_example(): return is_ben or is_tao # This will return either True or False depending on the Boolean expression. Statements # A statement is executed to perform an action.\nCompound Statements # A compound statement is a statement that contains groups of other statements.\nOne example of which are conditional statements, which give your code a way to execute a different suite of statements based on whether conditions are met:\nif \u0026lt;condition\u0026gt;: this_may_be_executed(1) elif \u0026lt;condition_2\u0026gt;: this_may_be_executed(2) else: this_may_be_executed(3) An if statement looks like the code above. The block indented after the if, elif, and else statements only get executed if the code directs it to.\nFor instance, if \u0026lt;condition\u0026gt; were True, then this_may_be_executed(1) is the only statement that gets evaluated, and the ones in the other blocks are skipped over.\nIf \u0026lt;condition_2\u0026gt; were True, then this_may_be_executed(2) is the only statement that gets evaluated.\nIf both \u0026lt;condition\u0026gt; and \u0026lt;condition_2\u0026gt; are False, then this_may_be_executed(3) is evaluated.\nThis means that the code does not get executed unless certain conditions are met, which is different from call expressions where every operand gets evaluated. (This property is important for some questions)\nAdditionally, this also allows for multiple return statements in functions because only that specific block gets executed, rather than every block.\ndef returning_conditional(x): if x \u0026gt; 0: return \u0026#34;positive\u0026#34; if x \u0026lt; 0: return \u0026#34;negative\u0026#34; if x == 0: return \u0026#34;neutral\u0026#34; While Loop # A while loop in Python executes a block of code as long as a condition is true. This loop keeps on getting checked after each iteration.\nOne problem of a while loop is that an infinite loop can easily occur if you aren\u0026rsquo;t careful.\ncounter = 1 while counter \u0026lt; 5: print(counter) counter += 1 \u0026#39;\u0026#39;\u0026#39; \u0026gt; 1 \u0026gt; 2 \u0026gt; 3 \u0026gt; 4 \u0026#39;\u0026#39;\u0026#39; In the example above, 5 does not get printed because during that iteration, the counter variable is already 5, and the conditional 5 \u0026lt; 5 returns False.\nA while loop is very useful if you do not know how many repeats of the code you need to do, while a for loop (explained on another page) is better if you know how many loops to do.\nBreak Statement # If you ever want to prematurely leave a code block, you can use the break keyword.\nwhile True: print(1) break # \u0026gt;\u0026gt;\u0026gt; 1 The above code would usually give an infinite loop, but the break statement prevents that from happening.\nFor Loop # A for loop in Python executes a block of code for a set number of times. It provides a cleaner way to write while loops as long as they are iterating over some sort of sequence, for instance, the range() function.\nThe for loop syntax is as follows:\nfor \u0026lt;name\u0026gt; in \u0026lt;expression\u0026gt;: \u0026lt;suite\u0026gt; Evaluate \u0026lt;expression\u0026gt; — this must evaluate to an iterable value (strings, lists (more on this later), range()) etc For each element in that \u0026lt;expression\u0026gt; (in order), bind \u0026lt;name\u0026gt; to the element in the current frame Execute the suite, with \u0026lt;name\u0026gt; bound to a new value. That might be slightly confusing for now, but just know that you can do everything a for loop can do with a while loop. So, if you see an example that uses a for loop, you can re-imagine it as a while loop, and it would still act the same.\nThe range() function # The range() function is used quite often in conjunction with the for loop. It represents a sequence of integers. There are 3 arguments that range() takes, each of which will be explained, then demonstrated below:\nIf there is just one argument x, range(x) will start on 0, then keep increasing the number by 1 until x - 1 (0 \u0026lt;= i \u0026lt; x where i is the current value) If there are two arguments x, y, range(x, y) will start on x, then keep increasing the number by 1 until y - 1. If there are three arguments x, y, z, range(x, y, z) will start on x, then keep incrementing the number by z (this can be negative), and then end on y - z. for n in range(5): # equivalent to range(0, 5) print(n) \u0026#39;\u0026#39;\u0026#39; \u0026gt; 0 \u0026gt; 1 \u0026gt; 2 \u0026gt; 3 \u0026gt; 4 \u0026#39;\u0026#39;\u0026#39; for n in range(1, 5): print(n) \u0026#39;\u0026#39;\u0026#39; \u0026gt; 1 \u0026gt; 2 \u0026gt; 3 \u0026gt; 4 \u0026#39;\u0026#39;\u0026#39; for n in range(5, 0, -1): print(n) \u0026#39;\u0026#39;\u0026#39; \u0026gt; 5 \u0026gt; 4 \u0026gt; 3 \u0026gt; 2 \u0026gt; 1 \u0026#39;\u0026#39;\u0026#39; As can be seen in the 3 examples above, the range() function works well with the for loop.\nWhen range() is passed only 1 parameter in a for loop, it starts off at 0, then ends off at the integer before n. With 2 parameters, the for loop\u0026rsquo;s value starts off at the first parameter\u0026rsquo;s value, then ends off at the integer before the second parameter\u0026rsquo;s value. The last parameter specifies the amount n should be changed by each loop, whether it be negative or a value other than 1.\n"},{"id":1,"href":"/cs61a/docs/week-2/higher-order-functions/","title":"Higher Order Functions","section":"Week 2","content":" Higher Order Functions # Designing Functions # Describing Functions # Aspect Example The domain of a function is the expected range of inputs (similarly to a domain in mathematics) x is a string The range of a function is the set of output values that could be returned Function square returns a non-negative number The behavior of a (pure) function is the relationship between the input and the output Function square returns the square of an input x Don\u0026rsquo;t Repeat Yourself! # When making a function, give each function exactly one job, but allow it to be flexible to apply to many related situations. Doing this allows you to remove redundant code and make your code clearer to read, and easier to write.\nGeneralization # If you see a common structure, you can refactor your code to move the redundant code to a function and call that instead.\nFor example, if we take this code block below:\ndef print_ben_if_positive(n): if n \u0026gt; 0: print(\u0026#34;ben\u0026#34;) def print_ben_if_positive(n): if n \u0026gt; 0: print(\u0026#34;tao\u0026#34;) We can see that the if statement is duplicated, so we can take that logic to another function instead, removing redundant code.\ndef positive_print(number, message): if number \u0026gt; 0: print(message) positive_print(n, \u0026#34;ben\u0026#34;) positive_print(n, \u0026#34;tao\u0026#34;) Higher-order Functions # A higher-order function is a function that takes another function as an argument, or returns a function as its result.\nFunctions as Arguments # A function can take another function as an argument.\nfrom operator import add, sub def function_in_function(adding_function, x, y): return adding_function(x, y) function_in_function(add, 3, 2) # \u0026gt;\u0026gt;\u0026gt; 5 function_in_function(sub, 3, 2) # \u0026gt;\u0026gt;\u0026gt; 1 In the example above, we passed the add and sub functions to the function function_in_function. This is an example of a higher order function.\nNote that in the call functions themselves, add and sub were called rather than add() and sub(). This is because of how call functions are evaluated. Running add() directly will make the Python interpreter try to evaluate the function itself with no parameters, which would not work, while simply typing add will allow function_in_function to evaluate add() with the proper parameters.\nFunctions as Return Values # Another way to have a higher order function is to return a function.\nFunctions created in other functions are bound to names in their local frame, allowing for cleaner naming when creating function calls. For example:\ndef make_adder(magnitude): def adder(n): return n + magnitude return adder add_two = make_adder(2) add_three = make_adder(3) print(add_two(2), add_three(2)) # \u0026gt;\u0026gt;\u0026gt; 4 5 While the example above may not have much practical use, it shows the process of returning a function within a function, making this another higher order function. Take your time to digest how the above two examples work. This will be harder to conceptualize at the beginning.\nCall Expressions as operator expressions # You can run a function like make_adder(2)(3) which will return 5. Why is that? Let\u0026rsquo;s look at how the call function order works.\nmake_adder(2) is first evaluated, which returns a function adder similarly to the function above. Due to adder being returned from the operator, the final statement will end up being adder(3), leading to 5 being the final output Lambda Expressions # Lambda expressions pretty much work the same way as regular functions, other than the fact that these functions are anonymous - they do not have a name assigned to it.\nThe syntax looks like the following:\nlambda \u0026lt;parameters\u0026gt;: \u0026lt;expression\u0026gt; For instance:\ndouble = lambda x: y*2 double(3) # \u0026gt;\u0026gt;\u0026gt; 6 While this may not seem very useful in this context, there are quite a few uses for it. The main idea is that lambda functions are better suited for functions that you want to access in the short term, or only access once.\nA lambda function does not contain any statements at all, including if statements and return statements.\nFor instance, instead of doing:\nfrom operator import add def square(x): return x**2 add(2, square(2)) You can do the following:\nfrom operator import add add(2, lambda x: x**2) Conditional Expressions # lambda functions not allowing statements can be quite limiting, but that is where conditional expressions come in.\nA conditional expression has a form that almost reads like English:\n\u0026lt;do this (true)\u0026gt; if \u0026lt;condition\u0026gt; else \u0026lt;do this (false)\u0026gt; This may be strange if you\u0026rsquo;re used to ternary operators in other languages (for example JavaScript) as the order of reading the Python statement may be a bit strange.\nHowever, the operation order is the following:\nCheck the truthiness of \u0026lt;condition\u0026gt; If true, evaluate \u0026lt;do this (true)\u0026gt; Else, evaluate \u0026lt;do this (false)\u0026gt; In conjunction with lambda functions, you can do the following:\nlambda x: x if x \u0026gt; 0 else 0 The code block above returns the input if it is positive, else returns 0.\n"},{"id":2,"href":"/cs61a/docs/week-2/environment-diagrams/","title":"Environment Diagrams","section":"Week 2","content":" Environment Diagrams # Environment Diagrams are a good way to visualize how Python deals with its execution, and can also help you to visualize how more complicated pieces of code (e.g. Higher Order Functions) work.\nPyTutor has a way of converting from code to environment diagrams, so please use that as a resource! The diagrams below are not going to match those from PyTutor exactly due to Markdown constraints, but I will try to emulate them as well as possible.\nVariable Assignment # x = 2 y = 5 When the code block above is run, the value 2 will be assigned to the name x, and afterwards, the value 5 will be assigned to the name y, which can be seen in an environment diagram like the one below:\nGlobal Frame 2 x 5 y In each frame, there can only be one name bound to one value - it is not possible to have one name point to two different values.\nFunction Assignment # Functions are notated differently to variables due to the potential need to overwrite a binding without losing the value of a function somewhere else (will make sense later).\ndef square(n): return n*n square(3) This will be executed in two different steps: creating the function, then executing the function.\ndef square(n): return n*n Global Frame func square(x) [parent = Global] square square(3) When a function is called, a new frame is created, leading to another environment for Python to execute code from. Note that an environment variable only needs the function name, parameter(s), and parent frame in the environment diagram.\nf1: square(x) [parent = Global] Global Frame 3 n 9 Return Value func square(x) [parent = Global] square As can be seen in the environment diagram above, a new unique frame f1 is created, which has all the passed in parameters (in this case, just n = 3) stored. Then, when the return statement is reached, it simply evaluates the right side of the return statement (in this case n*n), then returns that value (9)\nConfusing Function Assignment Example # (Taken from Fall 2021 Discussion 1)\ndef double(x): return x * 2 def triple(x): return x * 3 hat = double double = triple The functions double and triple\u0026rsquo;s environment diagrams are pretty self-explanatory, but the next two statements hat = double and double = triple are slightly more confusing. Let\u0026rsquo;s break it down:\nGlobal Frame func double(x) [parent = Global] double func triple(x) [parent = Global] triple What would happen with hat? In this case, it points to the function double(x) rather than the name double itself. This means that hat becomes a copy of double rather than acting as double. Take a look at the environment diagram below:\nGlobal Frame func double(x) [parent = Global] double func triple(x) [parent = Global] triple hat Both double and hat point to the same function double(x)!\nNow, what would happen with double = triple? You can simply extrapolate the actions above, but quite simply, the pointers change.\nGlobal Frame func triple(x) [parent = Global] double triple func double(x) [parent = Global] hat This means that you can still call the double(x) function through hat, but you can no longer call it through double. Additionally, even when double was overwritten, the function double(x) itself was not deleted!\nCall Expressions # The important thing to note is that when executing call expressions, a new frame is created to keep track of local variables. The order of operations is as follows:\nEvaluate the operator - this should evaluate to a function. Evaluate the operands from left to right. Make a new frame with: A unique index The real name of the function (not the name of the variable pointing to it) (for example, for double(n)) The parent frame Bind values to names in this new frame. Evaluate the function in this new frame until a return value is obtained. Example from Fall 2021 Discussion 1:\ndef double(x): return x * 2 hmmm = double wow = double(3) hmmm(wow) Global Frame func double(x) [parent = Global] double hmm After the function double(x) is bound to a name, and hmm is bound to that function, we create a new frame to evaluate wow = double(3).\nWhen evaluating that statement, the right side is evaluated before being assigned to the name on the left side. As a result, wow will not appear in the environment diagram until after the return value is created.\nf1: double(x) [parent = Global] Global Frame (After the return value below is evaluated) 3 x 6 Return Value func double(x) [parent = Global] double hmm 6 wow Afterwards, hmmm(wow) is called, which is essentially the same thing as doing hmmm(6). As hmmm is pointing to func double(x) [parent = Global], it will run that function, passing in the parameter 6. However, because this is a new function, a new frame will be created.\nf2: double(x) [parent = Global] f1: double(x) [parent = Global] Global Frame (After the return value below is evaluated) 6 x 12 Return Value 3 x 6 Return Value func double(x) [parent = Global] double hmm 6 wow Nested Call Expression # Environment diagrams can also help visualize how to deal with nested call expressions.\nFor example:\ndef double(x): return x*2 result = double(double(2)) How would this look in an environment diagram?\nFirst, the inner double(2) gets evaluated, so a frame is created for that, then the return value from that is used in the outer function, so another frame is created for that.\nf1: double(x) [parent = Global] Global Frame 2 x 4 Return Value func double(x) [parent = Global] double After the inner function is evaluated, the return value is then passed into the function to be run again in another frame:\nf2: double(x) [parent = Global] f1: double(x) [parent = Global] Global Frame 4 x 8 Return Value 2 x 4 Return Value func double(x) [parent = Global] double Note: Both of the parents of the function are the global frame because the function itself is called, and that is located inside the parent frame.\nNames in Environments # Names have different meanings in different environments!\ndef double(double): return double + double double(2) Please do not write code like this. It is merely a demonstration of how names and environments interact.\nf1: double(double) [parent = Global] Global Frame 2 double 4 Return Value func double(double) [parent = Global] double Notice how the different environment frames allow for the name double to exist twice with different assignments.\nEnvironment Diagrams for Higher-order Functions # Note that functions are first class in Python - they act the same as values.\nHOF: Takes a function as an argument # def run_twice(func, *args): return func(func(*args)) def double(x): return x*2 double_double = run_twice(double(2)) What *args does here is simply allow for a flexible number of arguments to be passed in rather than a set number - allows for more flexibility even though it doesn\u0026rsquo;t do much here.\nGlobal Frame func run_twice(func, *args) [parent = Global] run_twice func double(x) [parent = Global] double After assigning the functions to the names, we get the environment diagram seen above. To evaluate double_double = run_twice(double(2)), you have to remember the order of operations for call functions. First, evaluate the operators (make sure it exists/is not a higher order function), then evaluate the operands, then apply the operator to the operands.\nIn this context it means that run_twice is evaluated first with the proper pointers, then double is run after that is done.\nf2: double(x) [parent = Global] f1: run_twice(func, *args) [parent = Global] Global Frame 3 x 6 Return Value func 3 args func run_twice(func, *args) [parent = Global] run_twice func double(x) [parent = Global] double Afterwards, we get the following:\nf3: double(x) [parent = Global] f2: double(x) [parent = Global] f1: run_twice(func, *args) [parent = Global] Global Frame (Only after f3\u0026#39;s return value is evaluated) 6 x 12 Return Value 3 x 6 Return Value func 3 args 12 Return Value func run_twice(func, *args) [parent = Global] run_twice func double(x) [parent = Global] double 12 double_double These environment diagrams do get somewhat complicated.\nHOF: Nested Environment Diagrams # Notice how the parent for functions was always Global? Well with nested environment diagrams, you\u0026rsquo;ll finally see a situation where the parent isn\u0026rsquo;t always Global!\ndef make_adder(n): def adder(x): return x + n return adder add_3 = make_adder(3) add_3(2) Global Frame f1: make_adder(n) [parent = Global] f2: adder(x) [parent = f1] func make_adder(n) [parent = Global] make_adder add_3 3 n func adder(x) [parent = f1] adder Return Value 5 x 5 Return Value After the code has finished executing, we can see that the environment diagram. There are some points to take note of.\nVariable Finding Procedure # This was briefly mentioned in an earlier post, but the order is as follows:\nFind name in local frame If that could not be found, search one parent up and see if they have the name in that frame. Repeat until there are no more parent frames. If nothing could be found, throw an error Why is this important?\ndef make_adder(n): def adder(x): return x + n # Important on this line return adder As you can see, the variable n is not located within the actual code body of adder, meaning that the program would not be able to execute the function if it were only allowed to search from its local frame. adder\u0026rsquo;s parent is make_adder (and its parent frame is Global), meaning that when adder is run as a function, it can search for a specific variable in its own frame, its parent frame after that (make_adder), and the parent of its parent (Global)\nHere\u0026rsquo;s a good exercise to test your understanding (Taken from lecture 5 of Fall 2021):\ndef thingy(x, y): return bobber(y) def bobber(a): return a + y result = thingy(\u0026#34;ma\u0026#34;, \u0026#34;jig\u0026#34;) What would be returned here?\nSpoiler: It\u0026rsquo;s an error. Why? Let\u0026rsquo;s make an environment diagram.\nf2: bobber(a) [parent = Global] f1: thingy(x, y) [parent = Global] Global Frame jig a ma x jig y func thingy(x, y) [parent = Global] thingy func bobber(a) [parent = Global] bobber Notice how f2 only has the variable a that it can access in its environment, and the variable y cannot be found within its own environment, nor can it be found in any parent after that (which in this case would just be Global Frame). As a result, this throws an error because a name could not be found.\nSelf-Referencing Functions # A higher order function could return a function that references its own name. Take this for example:\ndef print_sums(n): print(n) def next_sum(k): return print_sums(n + k) return next_sum print_sums(1)(3) This is quite complicated to read but understanding it is well worth the cost.\nAs you can see above, the next_sum function with parent print_sums returns print_sums itself, meaning that it\u0026rsquo;s a function that references itself, hence being self-referential.\nLet\u0026rsquo;s try to make an environment diagram for that:\nf1: print_sums(n) [parent = Global] Global Frame 1 n func next_sum(k) [parent = f1] next_sum Return Value func print_sums(n) [parent = Global] print_sums After f1 has been evaluated, we can see that the return value of f1 returns a function. Now looking at the print_sums(1)(3) statement, we can see that print_sums(1) evaluated to a function, meaning that you now have something equivalent to next_sum(3), and the value of n in that function can be found by looking at its parent frame.\nf2: next_sum(k) [parent = f1] f1: print_sums(n) [parent = Global] Global Frame 3 k 1 n func next_sum(k) [parent = f1] next_sum Return Value func print_sums(n) [parent = Global] print_sums At that point, the function print_sums is called again, leading to this:\nf3: print_sums(n) [parent = Global] f2: next_sum(k) [parent = f1] f1: print_sums(n) [parent = Global] Global Frame (Only after f3 finishes evaluating) 3 k Return Value 4 n func next_sum(k) [parent = f3] next_sum Return Value 1 n func next_sum(k) [parent = f1] next_sum Return Value func print_sums(n) [parent = Global] print_sums As there are print statements in the function, there will also be something output to the console, which in this case is the following:\n1 4 Confusing? Sure, but it\u0026rsquo;s important to be able to draw these environment diagrams to help visualize certain parts of code.\nIt\u0026rsquo;s important to note that if another call were to be made after this function call, the parent of the next frame would be f3 as there is updated information in the outer function.\nCurrying # Currying takes a single function that takes multiple arguments and turns it into a higher-order function with single arguments.\nLet\u0026rsquo;s take a look at the differences between the following functions:\nfrom operator import add add(2, 3) # two arguments def make_adder(n): return lambda x: n + x make_adder(2)(3) # higher order function with one argument in each Above, make_adder is an example of currying add(2, 3).\nA way to curry a function with any two arguments can be done like this:\ndef curryer(f): def g(x): def h(y): return f(x, y) return h return g What this does allows only a single argument to be passed into the function each time (similarly to make_adder), but because of the rules of name lookup in Python, the variables x, y, and f can still be accessible from the innermost function. You can try inputting it into PyTutor, but for this one, it\u0026rsquo;s a good exercise to try and draw it yourself before checking the answers.\n"},{"id":3,"href":"/cs61a/docs/week-1/basics-of-python/","title":"Basics of Python","section":"Week 1","content":" Basics of Python # Expressions and Values # Programs work to manipulate values Expressions in programs evaluate to values Values can have different data types (string, float, boolean, integer, etc.) Python evaluates these expressions, and then (potentially) displays its values Data Types # Data Type Example Values Integers 2, 44, 25 Floats 3.14, 2.73, 69.69432 Booleans True, False Strings \u0026ldquo;Hi\u0026rdquo;, \u0026ldquo;ben\u0026rdquo; Operators # These are pretty self-explanatory\nOperator Example Expression What it does + 10 + 2 Adds two values together - 10 - 2 Subtracts values * 10 * 2 Multiplies values / 10 / 2 Divides values // 9 // 2 Takes the floor of the divided value (result on the left would evaluate to 4) % 9 % 2 Takes the remainder of the division expression (result on the left would evaluate to 1) ** 2 ** 2 Finds the value of the left value to the power of the right value Call Expressions # Oftentimes, however, expressions use function calls rather than operators (and the operators above have call function equivalents!)\nFor example, running add(10, 2) does the same thing as 10 + 2 as shown in the example above, but with different form.\nWhy use call functions? # One possible reason is that call functions are sometimes a lot easier to understand, especially when you have multiple nested call functions (as opposed to multiple mathematical operators)\nA call function always executes the same way with the same procedure, which goes as follows:\nadd(10, 69) # add is the operator, 10 and 69 are the operands in this instance. Python will first evaluate the operator (and), then will evaluate the operands (10, then 69), then apply the operator (function) to the operands (arguments), in that order, which can be summarized as follows:\nEvaluate the operator Usually this means check to see if it exists, but the operator itself may be a function in some situations. Evaluate the operand(s) Apply the operator to the operand(s) Operators and more commonly, operands can also be written as expressions, so these must be evaluated before step 3 can occur (meaning that if you have any sort of errors in that code block, Python will throw an error!)\nExample of nested expressions # from operator import add add(add(3,add(3,2)),add(add(5,4),add(7,6))) While the above example above is very impractical and will not appear in any sort of serious coding, it is a pretty good example of how Python evaluates nested expressions.\nLet\u0026rsquo;s unpack how Python deals with the above expression!\nPython reads from left to right in this expression, so first the add operator will be evaluated Next, the leftmost argument for add will be read, which in this case is the large block add(3,add(3,2)) As this is still another call function, the add will be evaluated, with the operands 3 and add(3,2) 3 is a \u0026lsquo;base case\u0026rsquo;, so that does not need to be further evaluated, but add(3,2) goes through the same procedure, which will then evaluate to 5. Now because the inner add function has been fully evaluated, the value is calculated in reverse order 3 + 5 is calculated, which will return 8 for the first argument. Same thing happens for the other operand, which will then evaluate to 22 22 and 8 get summed, which will then result in 30 Names # A name can be bound to a value. This does not necessarily need to be a variable - it could also be a function or an expression for instance.\nNames are often used because they can be reused in different parts of the code. A name that\u0026rsquo;s bound to a value is known as a variable.\nFor example:\nx = 2 y = 3 print(x + y) # Returns 5 print(x - y) # Returns -1 These values can also change:\nx = 2 print(x) # \u0026gt;\u0026gt;\u0026gt; 2 x = x + 5 print(x) # \u0026gt;\u0026gt;\u0026gt; 7 The equals sign used above is not similar to the one used in mathematics; it is used for assignment rather than equality, which means that you set a value to the variable.\nThis assignment statement works by:\nEvaluating the expression on the right of the = Binding the value of the expression to the name on the left side of the = Environment Diagrams # These are very useful to visualize how the Python interpreter thinks (and also appear somewhat often in exam questions). PyTutor is a very good resource to generate these environment diagrams if you ever get confused about how assignment works.\nFunctions # Functions are very useful in programming languages in general because they allow lines of code to be easily reused. Functions, however, are slightly more complicated than variables due to the local and global frames (more on that later).\nWhat is a function? # A function is a sequence of code that can be called on at any point in the program.\nWhile there are built in functions (like the add(a, b) function used earlier), sometimes, they need to be built by hand.\nA function has two portions: an input (the arguments a and b) and an output (a return value). These are not required, but depending on the use case of the function, they are very useful.\nHow do we write a function? # There are two common methods to write a function in Python, with the most common one being the def statement, which can be written in the format below:\ndef \u0026lt;name\u0026gt;(\u0026lt;parameters\u0026gt;): return \u0026lt;expression\u0026gt; For example, instead of using the built-in add() function from Python, we can create our own by doing the following:\ndef add(a, b): return a + b After the code is defined (e.g. below the function definition), you can then call it:\nadd(5, 6) # \u0026gt;\u0026gt;\u0026gt; 11 In python, the first line is the function signature, and all lines thereafter (there can be more than 1) are considered the function body.\nThe return keyword # In a Python function statement, the return keyword is vital. What it does is return a value to the place where the function was called, and then exits the function (both properties are very important to remember!)\nThe return keyword acts very differently to print, even if they are in the same function. Print does not do any assignment, while return does. The example below may help illustrate my point:\ndef example(x): print(x) return x*2 value = example(3) # Running the above line will print 3 first, then assign 3*2 to value print(value) # \u0026gt;\u0026gt;\u0026gt; 6 Frames # There are different frames, which you can think of as different rooms in the same house.\nThe global frame is an environment that contains all the variables and functions that were created in the main body of the program.\nA function\u0026rsquo;s local frame is a child of the global frame, where it has its own set of variables that can\u0026rsquo;t be accessed outside the function. For example:\nunhelpful_name = 0 # variable in the global frame def unhelpful_function(unhelpful_name): # variable in the local frame (even though it has the same name it isn\u0026#39;t the same variable) return unhelpful_name # \u0026gt;\u0026gt;\u0026gt; 2 # The above will return 2 as opposed to 0 because the unhelpful_name variable called in the function is the one passed into the function. unhelpful_function(2) Name Lookup Rules # Python looks up names in a user-defined function using the following logic:\nLook it up in the local frame If the name is not in the local frame, look for the name in the parent frame If the name is not in any searched frame, throw a NameError. Ending Notes # If you don\u0026rsquo;t understand any of this, it is very important to ask for more help, whether that be from your peers or from your TAs, or even searching on the internet. Another very useful resource (especially for understanding how frames work) is PyTutor. Please use it.\n"},{"id":4,"href":"/cs61a/docs/week-12/calculator-language/","title":"Calculator Language","section":"Week 12","content":" Calculator Language # Compiled vs Interpreted # High Level Languages (basically languages with a lot of abstraction from machine code - essentially 1s and 0s) are typically either compiled or interpreted.\nCompiling # When a program is compiled, the source code is directly translated to machine code right from the start - this code can then be distributed and run repeatedly.\nInterpreted # When a program is interpreted, the source code is run directly without first compiling it. This gives interpreted languages more overhead, but also makes it such that you remove the time needed for compilation.\nPhases of an Interpreter # In order to interpret source code, programs need to be written to understand said source code.\nA usual method is the following:\nSource Code -\u0026gt; Lexing -\u0026gt; Parsing -\u0026gt; Abstract Syntax Tree\nLexing and Parsing # The way to parse a scheme expression is to first collect the tokens of that expression (lexing), then turning it into a form readable by the language that it is to be interpreted by.\n(+ 1 (* 3 4)) -\u0026gt; Scheme Expression [\u0026#39;(\u0026#39;, \u0026#39;+\u0026#39;, \u0026#39;1\u0026#39;, \u0026#39;(\u0026#39;, \u0026#39;*\u0026#39;, \u0026#39;3\u0026#39;, \u0026#39;4\u0026#39;, \u0026#39;)\u0026#39;, \u0026#39;)\u0026#39;] -\u0026gt; Tokenized Pair(\u0026#39;+\u0026#39;, Pair(1, Pair(Pair([...])))) -\u0026gt; Parsed Lexical Analysis # Lexical Analysis is the process of turning an expression to its tokens. For example, the code block above shows lexical analysis of the phrase (+ 1 (* 3 4)) to our tokens ['(', '+', '1', '(', '*', '3', '4', ')', ')'].\nThis process is iterative, and processes lines one at a time.\nSyntactic Analysis # The syntactic analysis turns our tokens into a parsed form that is readable by programs. For example, the Pair class is used in the Python interpreted version of the calculator language.\nThis process is tree-recursive - it eventually returns a tree-like structure using linked lists and then processes multiple lines.\nPair Class # The Pair class is what\u0026rsquo;s used in CS61A to represent scheme lists.\ns = Pair(1, Pair(2, Pair(3, nil))) print(s) # (1 2 3) len(s) # 3 Calculator Language # Programming languages have the following features:\nSyntax: The statements and expressions in the code Semantics: The rules for evaluation within those statements and expressions When creating a new programming language, we need the following things:\nDocumentation (for how to use the program) Canonical Implementation (an interpreter/compiler for the language) Syntax # Our calculator expression will only have primitive expressions (numbers) and call expressions (+, -, *, /) with nothing else. This will give us the power to write mathematical expressions in scheme, then parse it using our parser.\nThe image above shows an example of an expression and the lexing and parsing that occurs from it.\nSemantics # The evaluation rules for a calculation expression is defined recursively.\nPrimitive: expresses to itself Call Expression: Evaluates to its operator applied on its operands. If we look at the expression tree above, whenever there\u0026rsquo;s a box, we need to evaluate the result from said box (which keeps going down until there are no more boxes to evaluate)\nEvaluation # This evaluation function computes the value of our expression. This function basically just looks at the data type then applies a different rule.\ncalc_eval # def calc_eval(exp): if isinstance(exp, (int, float)): return exp # if number, just give back a number elif isinstance(exp, Pair): arguments = exp.rest.map(calc_eval) # evaluate the rest of the arguments in the pair return calc_apply(exp.first, arguments) # apply the operator to the operands else: raise TypeError calc_apply # def calc_apply(operator, args): if operator == \u0026#39;+\u0026#39;: return reduce(add, args, 0) elif operator == \u0026#39;-\u0026#39;: ... elif operator == \u0026#39;*\u0026#39;: ... elif operator == \u0026#39;/\u0026#39;: ... else: raise TypeError "},{"id":5,"href":"/cs61a/docs/week-5/containers/","title":"Containers","section":"Week 5","content":" Containers # Lists # A list is a container that can hold a sequence of information (usually related information).\nLists can hold any Python values (not the same behaviour in every language), including other lists/objects etc.\nempty = [] # empty list B = [\u0026#34;Ben\u0026#34;, \u0026#34;Box\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;Bufy\u0026#34;] # Strings numbers = [2, 5, 7] # Integers floats = [2.0, 3.5, 7.5] # Floats nested = [[2, 3], 3, 4] # Storing a list inside a list mixed = [\u0026#34;Hi\u0026#34;, 2, 3.2] # Different data types inside a list List Length # The globally defined len() function in Python allows you to find the length of an array, and can be called by simply passing in the array as an argument.\nlst = [2, 3, 4, 5] \u0026gt;\u0026gt;\u0026gt; len(lst) 4 This could be useful if you wanted to count the number of elements in an array to calculate the average for instance.\nWhile you could store the length of the list in a variable, it\u0026rsquo;s usually not a good idea because once the list is updated, the variable storing the length will not be updated. As a result, it\u0026rsquo;s not a bad idea to always call len() when you need to find the length unless you have a specific use for storing an outdated list length.\nlength_of_list = len(lst) # 4 lst = lst + [6] # [2, 3, 4, 5, 6], more on list concatenation later \u0026gt;\u0026gt;\u0026gt; len(lst) 5 \u0026gt;\u0026gt;\u0026gt; length_of_list 4 Indexing (Accessing List Elements) # Now that we have a list, well, cool! But how do we access individual elements?\nWe can use indexing for that. Each element in the list has its own index (indexes start on 0), and can be accessed by putting the index of the element in question in a square bracket.\nlst = [2, 3, 4, 5] # Index: # 0 1 2 3 \u0026gt;\u0026gt;\u0026gt; lst[0] 2 \u0026gt;\u0026gt;\u0026gt; lst[3] 5 to_get = 2 \u0026gt;\u0026gt;\u0026gt; lst[to_get] 4 \u0026gt;\u0026gt;\u0026gt; lst[4] # Will throw an error In Python, negative indices are also possible. Calling a negative index on a list will return the elements starting from the back.\n\u0026gt;\u0026gt;\u0026gt; lst[-1] 5 \u0026gt;\u0026gt;\u0026gt; lst[-2] 4 \u0026gt;\u0026gt;\u0026gt; lst[-5] # Will throw an error Notice how the first element from the back is -1 rather than 0? A somewhat easy way to imagine why that\u0026rsquo;s the case is to imagine negative indices being shorthand for len(lst) - \u0026lt;index\u0026gt; — so for example, lst[-1] would be len(lst) — equal to 4 — then minus 1, which would give 3, so it\u0026rsquo;s effectively the same thing as calling lst[3].\nList Concatenation # You can add two lists together by using the + operator, or the add function, meaning that you can change the information stored in a list.\nFor now, you will only be able to add to a list with this operator (the - operator does not work on lists), but in the next page, you will see a method of how to take a subset of a list, which essentially does the same thing as removing elements in a slightly safer manner.\nlist1 = [1, 2, 3, 4] list2 = [5] \u0026gt;\u0026gt;\u0026gt; list1 + list2 [1, 2, 3, 4, 5] \u0026gt;\u0026gt;\u0026gt; add(list1, [6]) [1, 2, 3, 4, 6] For those used to other languages, you may see .append and .push used, but those actually change the values of the array, which can easily be circumvented by just adding two lists together and assigning that to a new variable. That way you have access to old versions of your variables, making your code slightly easier to read/debug.\nList Repetition # You can also use the * operator and the mul function with lists — however you can only multiply (vanilla Python) lists with an integer, which would repeat the elements already in the list. For example:\nlst = [1, 2, 3] lst3 = lst * 3 \u0026gt;\u0026gt;\u0026gt; lst3 [1, 2, 3, 1, 2, 3, 1, 2, 3] Nested Lists # As briefly mentioned earlier, you can also put lists inside of lists in Python. For example:\nlst = [[1, 2], [3, 4, \u0026#34;Hi\u0026#34;], []] If you think about this in the larger picture, lst itself only has 3 elements — 3 separate lists (with the contents inside them being irrelevant until they need to be accessed). However, once you access one of the lists, you then get another list returned (similarly to how higher-order functions worked when they returned other functions), which can then be indexed again to get a specific value.\n\u0026gt;\u0026gt;\u0026gt; lst[0] [1, 2] \u0026gt;\u0026gt;\u0026gt; lst[0][1] 2 So, knowing that information, what is the length of lst and the length of lst[2]?\nContainment # You can use the in operator to see whether a value is in a container. This operator, like ==, \u0026lt;, \u0026gt;, etc. returns a Boolean value in this context.\nlst = [1, 2, 3] \u0026gt;\u0026gt;\u0026gt; 1 in lst True \u0026gt;\u0026gt;\u0026gt; 2 in lst True \u0026gt;\u0026gt;\u0026gt; \u0026#34;2\u0026#34; in lst False \u0026gt;\u0026gt;\u0026gt; not (3 in lst) False \u0026gt;\u0026gt;\u0026gt; 12 in lst False \u0026gt;\u0026gt;\u0026gt; [1] in lst False # This one is false because none of the elements in lst are lists themselves For Statements # You can check the Control page to see the fundamental information on for loops and the range() function.\nFor lists, the range() function does not always need to be used.\nFor-in Loops # If you loop through a list, you can iterate through it without using range():\nlst = [1, 2, 3] for elem in lst: # In every iteration, it binds a value from `lst` to `elem` print(elem) # Console output: # 1 # 2 # 3 If you need to access deeper than 1 level, you can use a nested for-in loop.\nSequence Unpacking Example # lst = [[1, 2], [3, 4]] for a, b in lst: print(a + b) # Console output: # 3 # 7 Each name is bound to a value in this case (just like in multiple assignment)\nList Comprehensions # List comprehension in Python is a very elegant way to create a new list by mapping an existing list\u0026rsquo;s values to a new list.\nFor example, if you wanted to add 1 to every integer in a list, you could use list comprehension in the following manner:\nlst = [1, 2, 3, 4, 5] lst_plus_1 = [x + 1 for x in lst] # [2, 3, 4, 5, 6] And if you wanted to have a list that only contained odd numbers + 1, you could do the following:\nodd_lst_plus_1 = [x + 1 for x in lst if x % 2 == 0] # [2, 4, 6] The if statement acts as a filter — it only puts elements in the new array if it passes a condition.\nWe can generalize this structure to the following:\n[\u0026lt;map expression\u0026gt; for \u0026lt;name\u0026gt; in \u0026lt;iterator\u0026gt; if \u0026lt;condition\u0026gt;] The execution procedure for this (in an environment diagram) would be to:\nAdd a new frame with its current frame as its parent Create an empty result list For each element in iterator, bind it to name If condition returns a true value, then add the value of map expression to the result list in step 2. Strings vs Lists # Strings and lists have very similar behaviour (although naturally they do have some differences). They both can act as an iterator (so they can be used as an iterator in a for loop.\nSimilarities:\nstring = \u0026#34;ben\u0026#34; len(string) # 3 string[2] # n string + \u0026#34; baron\u0026#34; # ben baron However, they differ in these aspects:\nlst = [1] string = \u0026#34;B\u0026#34; string[0] == string # True lst[0] == lst # False (This is because lst[0] is equivalent to 1 as opposed to [1]) Additionally, the in operator will match substrings inside a string, but will not do so for a list.\nlst = [\u0026#34;bent\u0026#34;, \u0026#34;tao\u0026#34;] string = \u0026#34;bent\u0026#34; \u0026#34;ben\u0026#34; in lst # False \u0026#34;ben\u0026#34; in string # True "},{"id":6,"href":"/cs61a/docs/week-5/data-abstraction/","title":"Data Abstraction","section":"Week 5","content":" Data Abstraction # Many values in programs are compound values — a value composed of multiple values (for example coordinates, dates, or geographic positions).\nBy using a data abstraction, you can manipulate compound values as units without needing to worry about the way that values are stored.\nPair Abstraction # For data that is stored in pairs, we can manipulate these values using a pair data abstraction:\ncouple = pair(\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;) a = first(couple) b = second(couple) By implementing pair() (our constructor), first(), and second() (the selectors), you can access these elements without needing to worry about how the data is stored. The only time that people need to worry about how the data is stored is when implementing the functions themselves. One example (implying that there are multiple ways) of implementing these functions can be seen below:\ncouple = lambda a, b: [a, b] first = lambda lst: lst[0] second = lambda lst: lst[1] Rational Numbers # One reasonable data abstraction to do is to implement rational numbers as a data abstraction. By storing the numerator and denominator separately, we can get precise values of certain fractions such as 1/3.\nFor example:\nhalf = rational(1, 2) top = numerator(half) # 1 bottom = denominator(half) # 2 We have the structure for a denominator… cool I guess? But at its current state, we can\u0026rsquo;t do anything with the numbers in terms of multiplying/adding/printing them in the way that we expect. As a result, we can write more functions to help us do that using functions.\ndef mul_rational(x, y): return rational( numerator(x) * numerator(y), denominator(x) * denominator(y) ) def add_rational(x, y): nx, dx = numerator(x), denominator(x) ny, dy = numerator(y), denominator(y) return rational( nx * dy + ny * dx, dx * dy ) Notice how at this point we still do not know how rational() is implemented.\nImplementation # def rational(n, d): return [n, d] def numerator(rational): return rational[0] def denominator(rational): return rational[1] However, rational(n, d) doesn\u0026rsquo;t fully simplify the fractions, so to solve that, we can divide both n and d by the greatest common denominator:\ndef rational(n, d): g = gcd(n, d) return [n // g, d // g] Layers of Abstraction # You might be wondering, what\u0026rsquo;s the point of data abstraction?\nOne reason is that some things are a lot harder to code/understand (in terms of legibility) without using data abstraction in Python (for example coding a tree), but the main reason is for simplicity and extensibility.\nWhat data abstraction does is allow changing the implementation of the function itself without actually needing to manually change all the instances of it. In addition, with a good data abstraction, the programmer will not need to know how the data is implemented, but just needs to use the constructors and selectors to do the job for them.\nAbstraction Barriers # Layer Examples Representation/Implementation [x, y], [0], [1] Data Abstraction 1 make_rational, numerator, denominator Data Abstraction 2 mul_rational, add_rational User Programs Could be anything using the layer above Each layer would only need to use the layer above it, meaning that when users use the data abstractions, they do not need to care about how it\u0026rsquo;s implemented.\nHowever, this requires that the abstraction barriers are not violated. For example, if you were to do:\nadd_rational([1, 2], [3, 4]) You would be violating the abstraction barrier. This would not work if the implementation of rational were changed for instance. As a result, make sure to use both the constructors and the selectors instead of assuming what the implementation is.\nDictionaries # A dictionary is another way to store multiple pieces of data, however, it is stored differently to that of lists, and is also accessed slightly differently.\nEach element in a dictionary stores a key and a value as a pair, with each element separated by a , (similarly to lists) which looks like the following below:\nmy_fruits = {\u0026#34;apples\u0026#34;: 2, \u0026#34;bananas\u0026#34;: 25} If we had the following dictionary, we could call my_fruits[\u0026quot;apples\u0026quot;] to get the value of apples, which in this case would return 2. If we wanted to edit the amount of apples we had, we would then assign a value to the index: my_fruits[\u0026quot;apples\u0026quot;] = 3 would mutate our dictionary that we have.\nQueries # \u0026gt;\u0026gt;\u0026gt; \u0026#34;apples\u0026#34; in my_fruits # able to search for keys True \u0026gt;\u0026gt;\u0026gt; 2 in my_fruits # not able to search for values False \u0026gt;\u0026gt;\u0026gt; len(my_fruits) 2 Rules # keys cannot be a list or a dictionary (or any mutable type). However, values can be of any types (including dictionaries). There can only be one value mapped to every key (similarly to mathematical functions) Iteration # for fruit in my_fruits: print(fruit, my_fruits[fruit]) # apples 2 # bananas 25 Notice that fruit iterates through the keys and not the values!\nDictionary Comprehensions # Very similar to list comprehensions, but it uses {} instead of []; in the form of {\u0026lt;key\u0026gt;: \u0026lt;value\u0026gt; for x in \u0026lt;iter\u0026gt;}.\n{x: x*x for x in [1, 2, 3, 4]} # would return a dictionary of { 1: 1, 2: 4, 3: 9, 4: 16 } "},{"id":7,"href":"/cs61a/docs/week-3/decorators/","title":"Decorators","section":"Week 3","content":" Decorators # Python decorators allow you to wrap functions inside one another easily. These may not be seen that often in the CS61A course, but in general, are pretty good to know due to the simplicity that it has as well as the common usage of it in web frameworks such as Flask, or in larger codebases.\nExample Usage # Let\u0026rsquo;s take this trace function for example:\nIt returns a function that takes a single argument which traces the inputs and outputs of each function.\ndef trace1(f): def traced(x): print(f\u0026#34;Input: {x}\u0026#34;) result = f(x) print(f\u0026#34;Output: {result}\u0026#34;) return result return traced If we wanted to trace abs(-4) using trace1, we would call trace1(abs)(-4) to get an output in the console of:\n\u0026gt;\u0026gt;\u0026gt; trace1(abs)(-4) Input: -4 Output: 4 You could also use it in the following way if you wanted the trace function to be called on every instance of a function being called:\ndef square(x): return x*x square = trace1(square) The code above would then make sure the trace1 function is wrapped around every square call, meaning that when square is called, trace1 is always used.\nHowever, there is a shorthand way of doing the above, which is to use a decorator:\n@trace1 def square(x): return x*x "},{"id":8,"href":"/cs61a/docs/week-3/design/","title":"Design","section":"Week 3","content":" Design # Abstraction # Abstraction (in a CS context) is broadly understood as extracting relevant information from other sources in order to simplify the codebase.\nAbstraction by Parameterization # This is pretty much DRY (Don\u0026rsquo;t Repeat Yourself). Instead of hard-coding code that have similar structure, you could write a function that takes in parameters (arguments) which can be used to do the same thing. (Taken from CS61A Fall 2021 Design Slides)\ninterest = 1 + 0.6 * 2 interest2 = 1 + 0.9 * 4 interest3 = 1 + 2.1 * 3 As you can see above, there is a bunch of redundant code, which could be condensed into the function below (and then subsequently called with its respective arguments)\ndef interest(rate, years): return 1 + rate * years In this example, the removed detail, or the abstracted detail are the values themselves.\nAbstraction by Specification # Instead of building your own round function, you could just use Python\u0026rsquo;s built-in implementation, has its own specification for the inputs that it takes in (a number and the number of digits to round to), and then outputs a number based on that.\nAs a result, you could use this implementation of the round function in your code to save from implementing the code yourself.\nUsing an Abstraction # Say we have a specification for square(n) that takes an input n and returns the square of n. If we had this implemented already, we could use this function in our code. As a result, the code block below would run without any problems due to this abstraction.\ndef sum_squares(x, y): return square(x) + square(y) Implementing the Abstraction # There are many valid ways to implement this function, but some pieces of code are less efficient or have certain effects that you may not intend for it to have.\nFor example, take a look at the possible implementations of square:\ndef square(n): return n**2 square = lambda n: n*n square = lambda n: (n*(n-1)) + n Notice how the bottom implementation takes more computational resources than the 2 implementations above? This will be more important as the pieces of code written get more complicated — the size of the program and the time efficiency can be effected by poor implementations.\nReasonable Names # Choosing Names # While the computer does not care about names, it greatly improves readability for humans — even yourself when you look back at the code at a later date.\nNames should convey the meaning or purpose of the values/functions bound to them. Function names specifically usually have names that convey their effect, their behaviour, or the value returned.\nParameter Names for Functions # Functions take in parameter names — these too can either convey meaning, or be needlessly confusing for human readers.\nThese parameters could also be explained in the docstring, typically placed directly below the function signature.\ndef summing_function(n, func): \u0026#34;\u0026#34;\u0026#34;Sums the result of applying the function func n times from 1 to N. n: int func(n: int): function -\u0026gt; int summing_function -\u0026gt; int \u0026#34;\u0026#34;\u0026#34; total = 0 for i in range(1, n + 1): total += func(i) return total Redundant Code # Names should also be used if a compound expression has been repeated. For example:\nif a == b and b \u0026gt; c: print(a == b and b \u0026gt; c) You can instead store a == b and b \u0026gt; c in a variable, then use that variable for the expressions later. (I understand that the code above is very useless, but it does demonstrate a point)\nresult = a == b and b \u0026gt; c if result: print(result) More Naming Tips # Typically, names with one character are not very helpful in real codes: names should be more descriptive than that. However, there are exceptions:\nn, k, i: Usually used to denote an integer x, y, z: Usually real numbers/coordinates/number inputs for functions f, g, h: Shorthand for function names Names should be long if they help self-document your code!\nDebugging + Errors # Types of Errors # There are different errors in Python, the most common being the following:\nLogic Error Syntax Error Runtime Error Logic Error # A program has a logic error if the program does not behave as expected. This will not necessarily output something in the console, but can sometimes be discovered as a failing test or a bug report from users. This is why it\u0026rsquo;s important to write doctests for the outputs you expect — you can be sure that the code does not have logic errors.\nOne (very common) example of a logic error is the off-by-one error, where you were off by one in your implementation of a while/for loop.\nSyntax Error # Each programming language has its own syntactic rules. If the rules aren\u0026rsquo;t followed, the program will not necessarily be able to parse the code, thus resulting in code that cannot be executed at all. To fix these syntax errors, use the Python error log in the console to see the traceback message and see which lines they occurred at.\nRuntime Errors # A very common example of a runtime error is the ZeroDivisionError. These errors will happen while a program is running, and in the case of Python, it stops the execution of the program completely.\nTracebacks # When reading a Python traceback (which occurs when an error occurs), make sure to look from the bottom to the top. That way, you can see the error that occurred, and the most recent calls before the error happened.\n"},{"id":9,"href":"/cs61a/docs/week-9/efficiency/","title":"Efficiency","section":"Week 9","content":" Efficiency # The efficiency of an algorithm is very important. While it isn\u0026rsquo;t too important in CS 61A due to the (relatively) small data set and number of computations needed, in big sets of data or some extremely computer taxing computations, efficiency makes a world of a difference in terms of actually being able to make computations.\nHowever, CS 61A still wants you to understand how to calculate efficiency in a broad sense.\nOrders of Growth # Here are some common orders of growth:\nOrder of growth Description Constant Growth Regardless of the input size, it will take the same amount of time Logarithmic Growth The number of steps increases proportionately to the logarithm of the input size (pretty good to aim for) Linear Growth The number of steps increases in direct proportion to the input size Quadratic Growth The number of steps increases in proportion to the square of the input size Exponential Growth The number of steps increases faster than a polynomial function can One way to tell the order of growth is to create a table of results comparing the input size with the number of operations. From there, we can extrapolate and see what the order of growth actually is.\nAdding to the front of a linked list # Input Size Operations 1 1 10 1 100 1 1000 1 If we look at this table, we can see that adding to the front of a linked list can be done in constant time (always the same number of operations depending on the input size). This is often referred to as O(1).\nFast Exponentiation # def exp_fast(b, n): if n == 0: return 1 elif n % 2 == 0: return square(exp_fast(b, n//2)) else: return b * exp_fast(b, n-1) square = lambda x: x * x This function finds what b ** n is. You don\u0026rsquo;t really need to care about how it\u0026rsquo;s implemented (other than the fact that it is implemented)\nInput Size Operations 0 1 8 5 16 6 1024 6 In general, you can see that as the input size goes up, the number of operations increases in a logarithmic manner (where the number of operations doesn\u0026rsquo;t really increase too much). This is a pretty good thing to strive for if possible because most of the time constant time is very hard to achieve.\nFinding value in a linked list # Input Size Operations 1 1 10 10 100 100 1000 1000 Pretty simple here - increases in linear (O(n)) time.\nNested For Loop over a 5x5 array # lst1 = [1, 2, 3, 4, 5] lst2 = [2, 3, 4, 5, 6] for one in lst1: # takes 5 operations for two in lst2: # 5 operations for cycles = 25 operations in total print((one, two)) Input Size Operations 1 1 5 25 10 100 20 400 Somewhat similarly obvious - this increases in quadratic time (O(n^2))\nRecursive Fibonacci # Remember our recursive solution for calculating fibonacci numbers? Let\u0026rsquo;s see the efficiency of that.\nInput Size Operations 1 1 2 3 7 41 8 67 20 21891 This increases even faster than quadratic time. It grows in exponential time (O(2^n))\nSimilar thing can apply for space efficiency - same rules apply, just for storage/memory needed rather than the approximate number of operations.\nMemoization # Memoization is a strategy used to reduce redundant computation by \u0026lsquo;remembering\u0026rsquo; the status of previous function calls.\nBy storing the results of every computation we\u0026rsquo;ve gone through so far, we do not need to recalculate fib(2) on the right branch.\nBy making a memoization higher-order function, we can use a function decorator to make all of our function calls \u0026lsquo;cache\u0026rsquo; its results.\ndef memo(fn): cache = {} def memoizer(n): if n not in cache: cache[n] = fn(n) return cache[n] return memoizer This way, when we call our new Fibonacci function, we grow in linear time rather than exponential time in terms of time complexity (but space complexity is obviously larger to the point of being O(n))\ndef memo(fn): cache = {} def memoizer(n): if n not in cache: cache[n] = fn(n) return cache[n] return memoizer @memo # basically does the same as saying fib = memo(fib), which makes it such that fib now points to the memoizer function def fib(n): if n == 0 or n == 1: return n else: return fib(n-2) + fib(n-1) # Now calling fib(n) will be a lot more efficient "},{"id":10,"href":"/cs61a/docs/week-7/generators/","title":"Generators","section":"Week 7","content":" What is a Generator # Generators can be used to create your own iterators with custom values. This is useful when you want to create an iterator with unpredictable results (for example numbers with irregular intervals, possibly based on different arguments in a given function).\nThe way you define a generator function is through the yield keyword (instead of return in a function). In this sense, a generator is a type of iterator that yields results from a generator function.\ndef numbers(): num = 0 while num \u0026lt; 3: yield num num += 1 Calling the generator function will return a generator (which itself is an iterator, which means the next function works similarly to how it does for iterators):\nnum_iter = numbers() next(num_iter) # 0 next(num_iter) # 1 next(num_iter) # 2 next(num_iter) # StopIterator How Generators Work # When the function called, Python immediately returns an iterator without running any lines of code in the function itself.\nWhen next is called on the iterator, it starts executing the body of the function until it hits the first yield statement. Once it hits the yield statement, the function pauses execution (not to be confused with return where the function completely stops executing), and when next is called again, the function will continue executing from where it paused. If it doesn\u0026rsquo;t find any yield statements from there, it raises a StopIteration exception.\ndef printer(n): print(\u0026#34;we have started\u0026#34;) while n \u0026lt; 3: yield n n = n + 1 printing = printer(0) next(printing) # we have started # 0 next(printing) # 1 next(printing) # 2 next(printing) # StopIteration We can use for loops over generators like we can over iterators:\ndef printer(n): print(\u0026#34;we have started\u0026#34;) while n \u0026lt; 3: yield n n = n + 1 for item in printer(0): print(item) # we have started (goes through the function body as normal) # 0 # 1 # 2 Why Use Generators? # For some functions, using generators can save a lot of computing time. This is because they only generate the next item when needed (instead of having to find every solution in a recursive solution for example, you can just compute one element as a time (as you need it) in certain situations).\nExample: Fibonacci Numbers # Instead of an iterative solution:\ndef fib(n): prev = 0 curr = 1 iterations = 1 while iterations \u0026lt; n: prev, curr = curr, prev + curr iterations += 1 return curr we can use a generator for this:\ndef gen_fib(): prev = 0 curr = 1 while True: yield prev prev, curr = curr, prev + curr This will allow you to generate Fibonacci numbers as needed.\nYield From # The yield from keyword allows you to yield from an iterable/iterator one at a time:\ndef lst_yielder(): lst = [0, 1, 2, 3] yield from lst lst = lst_yielder() next(lst) # 0 next(lst) # 1 next(lst) # 2 next(lst) # 3 However, one of the very cool things about yield from is that you can yield the results of another generator function, which makes it act sort of like recursion in a way.\ndef countdown(n): if k \u0026gt; 0: yield n yield from countdown(n - 1) When the function hits yield from countdown(n - 1), it makes another instance of countdown, with a lower value of n, which will then pause when it reaches yield n in the function body.\nGenerator Functions with Returns # Using a return keyword in a generator function does not work exactly as intended.\nRemember how earlier it was mentioned that if a function was unable to find another yield statement, it would cause a StopIteration error? Well, what a return statement does traditionally is exit out of a function, which in this case means that no further yield statement will be found. As a result, a StopIteration error will occur.\ndef f(x): yield x yield x + 1 return yield x + 2 list(f(1)) # [1, 2] With Return Values # def f(x): yield x yield x + 1 return x + 1 yield x + 2 list(f(1)) # [1, 2] Notice how nothing changed? Return values can\u0026rsquo;t be yielded in this way. There is a way to yield these return values, but it is not in the scope of CS61A.\nCount Partitions (Yield) # def partitions(n, m): \u0026#34;\u0026#34;\u0026#34;List partitions. \u0026gt;\u0026gt;\u0026gt; for p in partitions(6, 4): print(p) 4 + 2 4 + 1 + 1 3 + 3 3 + 2 + 1 3 + 1 + 1 + 1 2 + 2 + 2 2 + 2 + 1 + 1 2 + 1 + 1 + 1 + 1 1 + 1 + 1 + 1 + 1 + 1 \u0026#34;\u0026#34;\u0026#34; if n \u0026lt; 0 or m == 0: return else: if n == m: yield str(m) for p in partitions(n - m, m): yield f\u0026#34;{m} + {p}\u0026#34; yield from partitions(n, m - 1) This one is a bit difficult to understand. Let\u0026rsquo;s break it down:\nThe base case n \u0026lt; 0 or m == 0 has a return statement in it. What this means is that if we ever get to the point where either of these cases happen, a StopIteration error will occur, which in this program, means that specific combination will not be yielded.\nIn the case where n == m, it means that there will only be one possible combination to make up that partition, so that specific partition size will be yielded.\nAfterwards, we use a for loop to deal with the case where we do use m (because using yield from does not allow you to change the values that you want to yield), then just yield from the case where m isn\u0026rsquo;t used and it decreases by 1.\n"},{"id":11,"href":"/cs61a/docs/week-8/inheritance/","title":"Inheritance","section":"Week 8","content":" Inheritance # Inheritance is a powerful tool that is very often used to reduce redundant code. If you have more specific versions of a larger class, inheritance can be extremely useful. Using our Animal class from the Objects notes, we can use all its general attributes, but then add more specific classes.\nclass Animal: default_food = [] def __init__(self, name, energy = 100): self.name = name self.food = self.default_food[:] self.energy = energy self.times_fed = 0 def feed(self, food): self.food = self.food + [food] self.times_fed += 1 self.energy += 10 def play(self): if energy \u0026lt;= 20: return \u0026#34;Not Enough Energy\u0026#34; self.energy -= 20 self.is_happy = True # Creates new instance variable return f\u0026#34;{self.name} has {self.energy} energy.\u0026#34; my_cat = Animal(\u0026#34;Sochi\u0026#34;) my_cat.feed(\u0026#34;Tuna\u0026#34;) Instead of making my_cat an instance of the Animal class, we could instead create a Cat class that inherits from the Animal class - meaning that it contains the same class, methods, and instance variables as the Animal class (which can then be overridden).\nThe syntax for creating a class inherited from another class is shown below:\nclass Cat(Animal): pass Right now, this will create a new Cat class pointing towards the Animal class we\u0026rsquo;ve already created, meaning that it can also access the class attributes/variables alongside the methods of the Animal class.\nExample of Inheritance # In the image above, we can see the Cat class we created pointing towards the Animal class, meaning that in terms of our lookup order, we first look to see if something exists in the instance, then Cat, then Animal.\nFor example, let\u0026rsquo;s edit our Cat class a bit, so it has a use, then create an instance:\nclass Cat(Animal): default_food = [\u0026#34;Tuna\u0026#34;] sochi = Cat(\u0026#34;Sochi\u0026#34;) When sochi = Cat(\u0026quot;Sochi\u0026quot;) is called, it first looks for an __init__ method in its own class (Cat), which doesn\u0026rsquo;t exist, so it looks up to its parent (Animal) for an __init__, which is found, so that __init__ method is used. If there is no __init__ method in the lookup, that method will simply not be called.\nAs a result of that, we get the following diagram (in this case, the __init__ method is called from class Animal as that is the highest level where an __init__ is defined):\nCat → Animal +--------+ +------------------+ |default_| | default_food = []| |food = | | __init__() | |[\u0026#34;Tuna\u0026#34;]| | feed() | +--------+ | play() | +------------------+ When looking for self.default_food[:], default_food from the Cat class is taken, because the created instance first looks to see if there is a default_food already located in the instance (it doesn\u0026rsquo;t), then looks to where the arrow is pointing, which is the Cat class, then looks for default_food, which is then found.\nOur current version of the Cat class doesn\u0026rsquo;t really do much. We can override our default methods by simply redefining them in our new class. The lookup order will make it such that only our newly defined method will be called.\nclass Cat(Animal): default_food = [\u0026#34;Tuna\u0026#34;] def feed(self, food): self.food = self.food + [food] self.times_fed += 1 self.energy += 10000 Now our current diagram looks like this. If we call sochi.feed(\u0026quot;apple\u0026quot;), it will look at the feed method defined in Cat and then call it because it exists in that class.\nThe super() Function # The super() function, at least in the scope of CS 61A, looks at its parent class.\nThis could be useful if you wanted to use a method of the parent class but add a few extra details. The super() function automatically passes in self.\nclass Cat(Animal): default_food = [\u0026#34;Tuna\u0026#34;] def __init__(self, name, energy = 100): super().__init__(name, energy) # will automatically define instance variables from the Animal class self.is_very_cute = True def feed(self, food): self.food = self.food + [food] self.times_fed += 1 self.energy += 10000 Now, looking at our diagrams, we have the following:\nCat → Animal +--------+ +------------------+ |default_| | default_food = []| |food = | | __init__() | |[\u0026#34;Tuna\u0026#34;]| | feed() | |feed() | | play() | +--------+ +------------------+ If we then create an instance of our newly created Cat class, we will do the following:\nFirst, create our instance and find whether an __init__ exists:\nsochi → (○) Instance name: \u0026#34;Sochi\u0026#34; food: [\u0026#34;Tuna\u0026#34;] energy: 100 times_fed: 0 is_very_cute: True Then, if it does exist, we execute it.\nUse Cases # Explicit examples will not be given here because they should not be necessary. You can imagine the world of possibilities that you can do with classes and inheritance! Try thinking of how you would make a card game using OOP. Doing that will reduce A LOT of redundant code and make writing this card game easy. In fact, you might see this sort of thing show up in lab questions (alongside the Ants project).\n"},{"id":12,"href":"/cs61a/docs/week-12/interpreting-scheme/","title":"Interpreting Scheme","section":"Week 12","content":" Interpreting Scheme # Interpreters keep going through an evaluate/apply cycle.\nEval # Base Case # Primitive Values Recursive Case # Evaluate(operator, operands) of call expressions Apply(procedure, arguments) Apply # Base Case # Built in procedures Recursive Case # User defined procedures Scheme Specific Traits # Nearly everything in Scheme is a list (as mentioned countless times); additionally, nearly everything in scheme is a call expression where the operator is evaluated, then the operands are all evaluated, then these operands are applied to the operator.\nHowever, there are special forms that don\u0026rsquo;t follow this evaluation procedure, which means that we need to create our own ruleset for these special forms.\nEvaluation # Our scheme_eval function will choose its execution behaviour based on the expression form given to it:\nIf a primitive is given (booleans, numbers, nil, etc), that primitive is just returned as a value itself If there\u0026rsquo;s a symbol in the expression, try to look up the value in the frame. All other legal expressions are represented as Scheme lists (this could be normal call expressions or special forms) - these are called combinations Evaluating Combinations # We could have combinations that are call expressions and combinations that are special forms. How do we tell the difference between them such that we can choose how to evaluate them?\nLet\u0026rsquo;s try to look at examples to try and see the difference:\n(+ 1 2) (define x (+ 1 2)) (* 1 2) (if #f (/ 1 0) 0) Notice how the first \u0026rsquo;token\u0026rsquo; can be used to tell whether something is a call expression or a special form. If the first token (after the bracket) matches that of a known special form, we use a different evaluation procedure, else we just do the normal scheme special from evaluation procedure.\nSymbols and Functions # Frames # Similarly to Python, Scheme variable looks at frames to find the values bound to symbols. In our interpreter, we will represent frames as Frame class instances. Each Frame object will have a lookup and define method. In this version we will not hold return values, but some other implementations may do that.\nDefine Expressions # Define would bind a symbol to a value to the first frame of the current environment that the code is in. If we need to define a procedure, what happens is that a lambda function is created, then that lambda function is the bound to the name.\nApplying User-Defined Procedures # When applying user-defined procedures, we need to create a new frame where the arguments of the functions are defined, and then makes it such that the parent of the frame is just the env attribute of the procedure (you will see this in the Scheme Project code)\n"},{"id":13,"href":"/cs61a/docs/week-7/iterators/","title":"Iterators","section":"Week 7","content":" What is an Iterator # An iterator is an object that provides sequential access to values in an iterable one by one.\nWhile you may not see the use of them at the moment, the benefits of using them will be explained a bit later in these sets of notes.\niter(iterable) returns an iterator over the elements of iterable. next(\u0026lt;iter\u0026gt;) returns the next element in an iterator. numbers = [1, 2, 3] iter_numbers = iter(numbers) next(iter_numbers) # 1 next(iter_numbers) # 2 next(iter_numbers) # 3 next(iter_numbers) # Error (StopIterator exception) In CS61A, questions will never get to the point where handling the StopIterator error will need to happen, but a try \u0026hellip; except code block can handle that error. If you ever get a StopIterator error in your HW or Lab questions, you can just assume you did something wrong.\nYou can think of an iterator like a bookmark and a book.\nImagine we have a list lst that contains chapters of a book, with every element containing a single chapter:\nlst = [1, 2, 3, 4, 5, 6] When we call iter on said list, we essentially create a bookmark starting on chapter 0 (before any other chapters). After finishing a chapter, calling next on the iterator will move the bookmark to chapter 1.\nlst = [1, 2, 3, 4, 5, 6] bookmark1 = iter(lst) # [1, 2, 3, 4, 5, 6] - no bookmark so far # ^ next(bookmark1) # 1 # [(1), 2, 3, 4, 5, 6] - bookmark on 1 # ^ If we wanted to create a new bookmark with the same book, we can just call iter again, which would keep bookmark1 the same.\nlst = [1, 2, 3, 4, 5, 6] bookmark1 = iter(lst) bookmark2 = iter(lst) next(bookmark1) # 1 next(bookmark1) # 2 # [1, (2), 3, 4, 5, 6] - bookmark on 2 # ^ next(bookmark2) # 1 # [(1), 2, 3, 4, 5, 6] - bookmark on 1 # ^ Calling an Iterator on an Iterator # If you call iter on an already-made iterator, similarly to lists, it just points to the same iterator. With our bookmark analogy, it\u0026rsquo;s like getting another variable pointing to the same bookmark — calling next on one instance will also update the bookmark for the other variable.\nlst = [1, 2, 3, 4, 5, 6] bookmark1 = iter(lst) alt_bookmark1 = iter(bookmark1) next(bookmark1) # 1 next(alt_bookmark1) # 2 Calling Iterators on Iterables # strings, lists, dictionaries, tuples, ranges, etc. are all iterables. You can call iterators on them and access them sequentially. This should be pretty obvious, but there are special methods that exists for dictionaries.\nDictionaries # numbers = { \u0026#34;one\u0026#34;: 1, \u0026#34;two\u0026#34;: 2, \u0026#34;three\u0026#34;: 3 } # Iterator for keys key_iter = iter(numbers.keys()) next(key_iter) # \u0026#34;one\u0026#34; # Iterator for values value_iter = iter(numbers.values()) next(value_iter) # 1 # Iterators for key/value tuples dict_iter = iter(numbers.items()) next(dict_iter) # (\u0026#34;one\u0026#34;, 1) Iterators with For Loops # When an iterator is used in a for \u0026hellip; in loop, Python will keep calling next on the iterator until a StopIterator error occurs.\nlst = [1, 2, 3] iter_lst = iter(lst) for item in iter_list: print(item) # 1 # 2 # 3 next(iter_lst) # StopIterator error The for loop would go through the whole book, moving the bookmark to the end. As a result, when you call next again, the bookmark would be at the end, meaning that there are no more additional chapters, so a StopIterator error will occur.\nThis behaviour implies that iterators are mutable. One an iterator moves forward, it is unable to return the values that came before.\nUseful Built-in Functions # Functions that return iterables # Function Description list(iterator) Returns a list of all items in iterator starting on the current pointer location. tuple(iterator) Returns a tuple of all items in iterator starting on the current pointer location. sorted(iterator) Returns a sorted list of all items in iterator starting on the current pointer location. Functions that return iterators # These are slightly more complicated, so examples will be given for each of the following below:\nreversed(sequence) # Iterates over item in sequence in reverse order. Returns an iterator.\nlst = [1, 2, 3] print(list(reversed(lst))) # [3, 2, 1] # list() needs to be called because reversed returns an iterator for item in reversed(lst): print(item) # 3 # 2 # 1 zip(*iterables) # Iterates over co-indexed tuples with elements from each iterable. Stops at the shortest list.\nlst1 = [1, 2, 3] lst2 = [4, 5, 6] for t in zip(lst1, lst2): print(t) # (1, 4) # (2, 5) # (3, 6) for x, y in zip(lst1, lst2): print(x + y) # 5 # 7 # 9 Map and Filter # For map and filter specifically, you can simply use list comprehensions — they\u0026rsquo;re shorter and far more \u0026lsquo;Pythonic\u0026rsquo;. However, knowing the notation for these two functions can help you recognize them in other languages.\nmap(function, iterable) # lst = [1, 2, 3] mapped_lst = map(lambda x: x*2, lst) print(list(mapped_lst)) # [2, 4, 6] # Which is the same thing as [x*2 for x in lst] filter(function, iterable) # lst = [1, 2, 3] mapped_lst = map(lambda x: x % 2 == 1, lst) print(list(mapped_lst)) # [1, 3] # Which is the same thing as [x for x in lst if x % 2 == 1] "},{"id":14,"href":"/cs61a/docs/week-12/macros-exceptions/","title":"Macros and Exceptions","section":"Week 12","content":" Macros and Exceptions # Macros # In Scheme, everything is a list. For example, (quotient 1 2) can also be seen as a Scheme list with the elements quotient, 1, and 2. What the \u0026rsquo; operator lets us do in Scheme is create a list without evaluating certain options, then delay the evaluation until you need it later. For example:\n\u0026gt;\u0026gt;\u0026gt; (define lst (list \u0026#39;quotient 1 2)) lst \u0026gt;\u0026gt;\u0026gt; lst (quotient 1 2) \u0026gt;\u0026gt;\u0026gt; (eval lst) 0.5 \u0026gt;\u0026gt;\u0026gt; (eval (list \u0026#39;quotient 1 2)) 0.5 Quoting # There are two ways to quote an expression:\nQuoting Quasiquoting Quasiquotes are different because they allow certain elements to be unquoted using ,. This means that names can be bound directly:\n(define a 2) (define b 3) \u0026#39;(+ ,a b) ; (+ (unquote (a)) b) `(+ ,a b) ; (+ 2 b) When you call eval on the quasiquoted expression, it saves the value of a directly into the macro which can be very powerful.\nIf you try to call (eval '(+ ,a b)) you will get an error because , does not work unless it is in a quasiquote because Scheme.\nExceptions # Exceptions in Python are used to handle errors. In Python, you most likely would have seen quite a few exceptions (for example ZeroDivisionError, StopIteration, etc.) - there is a way to handle these exceptions.\ntry\u0026hellip;except # To handle an exception (which keeps the program running - it doesn\u0026rsquo;t make the program stop the moment an error appears), you can use Python\u0026rsquo;s built-in exception handling.\ntry: \u0026lt;body\u0026gt; except \u0026lt;exception\u0026gt; as \u0026lt;variable\u0026gt;: \u0026lt;body\u0026gt; [except \u0026lt;exception\u0026gt; as \u0026lt;variable\u0026gt; [...]] [else] First, the body in the try suite is executed first, then if an error is thrown that matches any \u0026lt;exception\u0026gt; that you put in, the body corresponding to that suite will be run with \u0026lt;variable\u0026gt; bound to the exception.\nExample # try: val = 10/0 except ZeroDivisionError as e: print(f\u0026#39;handling {type(e)}\u0026#39;) # handling \u0026lt;class \u0026#39;ZeroDivisionError\u0026#39;\u0026gt; val = 0 Example inside a function # def div(a, b): try: result = a / b except ZeroDivisionError: result = float(\u0026#39;inf\u0026#39;) return result div(10, 1) # 10 div(10, 0) # inf div(10, -1) # -10 What Would Python Do? # Taken from CS61A Fall 2021 Exceptions slides:\ndef invert(x): inverse = 1/x # Raises a ZeroDivisionError if x is 0 print(\u0026#39;Never printed if x is 0\u0026#39;) return inverse def invert_safe(x): try: return invert(x) except ZeroDivisionError as e: print(\u0026#39;ben\u0026#39;) return 0 invert_safe(1/0) # Error try: invert_safe(0) except ZeroDivisionError as e: print(\u0026#39;tao\u0026#39;) # ben # this is because the place where the error occurs is in the try except block where \u0026#39;ben\u0026#39; is printed Raising Exceptions # Assert Statements # assert statements that fail raise an exception of type AssertionError\nRaise Statement # You can raise any type of exception by using the raise statement:\nraise \u0026lt;expression\u0026gt; \u0026lt;exception\u0026gt; must evaluate to a subclass of BaseException (or an instance of one). Exceptions are constructed in the same way as do other classes:\nraise ZeroDivisionError(\u0026#34;lol wtf u doing\u0026#34;) "},{"id":15,"href":"/cs61a/docs/week-6/mutability/","title":"Mutability","section":"Week 6","content":" Mutability # Objects # An object is a bundle of data and behaviour, with each type of object called a class.\nEvery value in Python is an object.\nAll objects have attributes, and objects often have associated methods.\nExample (Strings) # A string is an object — try running type(\u0026quot;\u0026quot;) in Python console and seeing what it outputs.\nStrings have attributes (for example the data inside it) and also has methods such as string.upper().\nList Mutation # Lists (like dictionaries) are object types that can be mutated. This means that the value bound to the name can change without reassignment. This can potentially be very useful, but at times, can also be very dangerous due to the way Python works with lists.\nTwo methods to mutate lists:\ns = [1, 2] s.append(3) s # [1, 2, 3] l = [1, 2] l.extend([4]) l # [1, 2, 4] l.extend([3, 2]) l # [1, 2, 4, 3, 2] While these look identical to s = s + [3], they behave very differently. This is because the + operator makes a shallow copy of the list rather than directly mutating the list itself. This makes a difference when two names are pointing to the same list object.\nTry running the code below on PythonTutor:\nlst1 = [1, 2, 3] lst2 = lst1 lst3 = lst2 # Notice how after the above 3 statements are executed, all 3 names point to the same list object lst1 = lst1 + [3, 2] # Makes a copy of the list, does not mutate the original lst2.append(4) print(lst1) # [1, 2, 3, 3, 2] print(lst2, lst3) # [1, 2, 3, 4] [1, 2, 3, 4] Notice how even after I updated only lst2, lst3 got updated alongside it. This is one of the dangers of mutation (and is why I generally prefer to use a method that doesn\u0026rsquo;t mutate anything: it makes debugging a lot easier when variables aren\u0026rsquo;t changing without explicitly being assigned to change.)\nMethod Mutation (Removing) # pop() returns and removes the last element in the list remove() removes the first element equal to the argument s = [1, 2] s.pop() s # [1] l = [1, 2, 4] l.remove(2) l # [1, 4] Mutation with Slicing # You can also mutate lists with list slicing or indexing:\nlst = [1, 2, 3, 4, 5] lst[0] = \u0026#34;Hi\u0026#34; lst # [\u0026#34;Hi\u0026#39;, 2, 3, 4, 5] lst[1:3] = [25, 6] lst # [\u0026#34;Hi\u0026#34;, 25, 6, 4, 5] lst[1:1] = [3, 2, 1] # Inserting Elements lst # [\u0026#34;Hi\u0026#34;, 3, 2, 1, 25, 6, 4, 5] lst[:5] = [] # Deleting Elements lst # [6, 4, 5] lst[len(lst):] = [3] # Appending elements lst # [6, 4, 5, 3] All the statements above mutate the list that we have.\nPython Weirdness # In Python, doing lst = lst + [1] is different to lst += [1].\n+= actually acts as .extend([...]) rather than making a copy. As a result, doing lst += [1] mutates the original list, while lst = lst + [1] does not mutate the original. Weird behaviour, sure, but this is very important to know.\nTuples # Tuples are a data type that are immutable. This means that once the tuple is created and assigned to a name, you can be confident that the tuple will always remain the same unless the name is bound to a different value.\nTuples are also a sequence, which means you can view them as essentially immutable lists.\nempty = () # empty tuple coordinates = (32, 21) # tuple with multiple elements temperature = (30,) # tuple with 1 element (the , at the end is necessary for python to parse it as a tuple) The read-only list operators work with tuples:\nt1 = (1, 2) t2 = (3, 4) t3 = t1 + t2 t3 # (1, 2, 3, 4) 1 in t2 # False 1 in t3 # True t4 = t3[1:] # (2, 3, 4) Identity vs Equality # Identity vs Equality essentially boils down to is vs ==. The is Boolean operator checks whether the objects are the same (for example in the case of a list, whether the two names are pointing to the same list), while the == operator just checks whether the values are the same.\nlst1 = [1, 2] lst2 = lst1 lst3 = [1, 2] lst1 is lst2 # True lst1 is lst3 # False lst1 == lst3 # True \u0026lsquo;Mutable\u0026rsquo; Functions (A function with changing state) # You can have a function that changes state by having a mutable object in the parent frame:\ndef bank(initial_fund): bank_account = [initial_fund] def withdraw(amount): if bank_account[0] \u0026lt; amount: return \u0026#34;NO!\u0026#34; else: bank_account[0] = bank_account[0] - amount return bank_account return withdraw withdrawer = bank(100) withdrawer(25) # 75 withdrawer(25) # 50 "},{"id":16,"href":"/cs61a/docs/week-10/break/","title":"No Content This Week","section":"Week 10","content":" No Content This Week # No new content was covered this week due to Spring/Thanksgiving break.\n"},{"id":17,"href":"/cs61a/docs/week-7/objects/","title":"Objects","section":"Week 7","content":" Object Oriented Programming (OOP) # OOP is a method for organizing programs. It includes:\nData Abstraction Bundling together related programs/information/behaviour Each object can have its own local state (meaning its own variables), and also knows how to manage its own state. OOP is particularly useful when you have many similar things that can be further generalized to avoid repeating redundant code. For example, you could have an Animal object, with other sub-classes of the Animal (for example, Turtle, Cat, Bear, etc.) - this (inheritance) will be covered in the next page.\nTerminology # A class is a template for creating your own data type (for example, an Elephant class) An instance of a class is called an object (in this context, an instance would be one elephant in the Elephant class) Each object has its own variables called instance variables that describe its current state Each object can also have its own functions called methods Each class can have its own variables called class variables that contain information about the class itself Example # Let\u0026rsquo;s make an Animal class.\nI want each of my animals to have instance variables for food and happiness as well as methods (equivalent to functions) to have animals play with each other.\nIn Python, whenever we want to create an instance of a class, we just assign a variable to a call to the class:\nThe example below won\u0026rsquo;t necessarily make sense for now, but I\u0026rsquo;ll break it down later into smaller parts that will each be explained.\nclass Animal: default_food = [] def __init__(self, name, energy = 100): self.name = name self.food = self.default_food[:] self.energy = energy self.times_fed = 0 def feed(self, food): self.food = self.food + [food] self.times_fed += 1 self.energy += 10 def play(self): if energy \u0026lt;= 20: return \u0026#34;Not Enough Energy\u0026#34; self.energy -= 20 self.is_happy = True # Creates new instance variable return f\u0026#34;{self.name} has {self.energy} energy.\u0026#34; my_cat = Animal(\u0026#34;Sochi\u0026#34;) my_cat.feed(\u0026#34;Tuna\u0026#34;) Object Construction # In this case, Animal(\u0026lt;args\u0026gt;) is called the constructor.\nWhen our constructor (my_cat = Animal(\u0026quot;Sochi\u0026quot;)) is called, it does the following:\nCreate a new instance of the Animal class Call the __init__ method of the class with the new instance as the first argument (passed in as self), along with any additional arguments in the call expression. In this case, the new instance becomes self, and afterwards, is assigned to my_cat. This will hopefully make more sense after you see the diagram a bit below.\nThe Pythonic term for a variable wrapped in double underscores is called a dunder method.\nInstance Variables # class Animal: default_food = [] def __init__(self, name, energy = 100): self.name = name self.food = self.default_food[:] self.energy = energy self.times_fed = 0 Instance Variables are variables that each instance of an object (most likely) has, which describes the state of the object. These instance variables can be modified using each of the object\u0026rsquo;s methods. Additionally, new instance variables can be assigned outside the constructor.\nDot notation here (for example with self.name) allows you to access all attributes of an object (including both instance variables and instance methods). The left-hand side does not need to be self - it can be anything that evaluates to an object instance (more on this later).\nIn this case, self refers to the instance being passed in - not every animal is the same, so self shouldn\u0026rsquo;t refer to the same animal. This might be more clear with the next example.\nMutating Instance Variables # class Animal: default_food = [] def __init__(self, name, energy = 100): self.name = name self.food = self.default_food[:] self.energy = energy self.times_fed = 0 my_cat = Animal(\u0026#34;Sochi\u0026#34;) First, let me draw a representation of the Animal class that we\u0026rsquo;re referring to in the code block above. This is not the official Python Tutor environment diagram for a representation of classes, but this notation is a very clear way to see the lookup order of certain variables.\nClass Animal +------------------+ | default_food = []| | __init__() | | feed() | | play() | +------------------+ I haven\u0026rsquo;t put every single method in the class.\nAfterwards, when we call my_cat = Animal(\u0026quot;Sochi\u0026quot;), we create a new instance of the class. I will denote a new instance with a circle rather than a rectangle, label the newly created instance with my_cat (the name of the variable assigned to it), then an arrow will be drawn to the class that this instance refers to. This will be even more important when we look at inheritance in objects.\nmy_cat → (○) Instance name: \u0026#34;Sochi\u0026#34; food: [] energy: 100 times_fed: 0 Now, we can see that our variable my_cat has instance variables name, food, energy, times_fed, which can be mutated by either mutating my_cat or using methods, which we will show later.\nYou might be wondering where self.food comes from. In this case, self.default_food[:] will look for default_food in its own instance, which it can\u0026rsquo;t find because nothing is defined, so it will then look at the \u0026lsquo;frame\u0026rsquo; above, or in this case, the class itself for default_food, which it does contain. As a result, that value is used for self.food. You can think of this as variable lookup with different frames.\nTo mutate our instance, we can use my_cat to do so.\nmy_cat.energy += 10 Running the following line of code will look for whatever my_cat is pointing to, which in this case, is the instance, then find energy and update that.\nmy_cat → (○) Instance name: \u0026#34;Sochi\u0026#34; food: [] energy: 110 # Updated times_fed: 0 This is sort of like list mutation: you can access an element in the instance by using dot notation, then update it through assignment.\nMethod Invocation # Calling my_cat.feed(\u0026quot;Tuna\u0026quot;) will invoke the following function:\nclass Animal: def feed(self, food): self.food = self.food + [food] self.times_fed += 1 self.energy += 10 This does the same thing as calling Animal.feed(my_cat, \u0026quot;Tuna\u0026quot;) if you want to see where the self variable comes from.\nIn this case, my_cat gets implicitly passed in as self, so the first argument in my_cat.feed(\u0026quot;Tuna\u0026quot;) (Tuna) will get passed in to feed as food.\nAs a result, we will update our instance variables following the instructions in the function, where self refers to the instance we made in the image above.\nmy_cat → (○) Instance name: \u0026#34;Sochi\u0026#34; food: [\u0026#34;Tuna\u0026#34;] energy: 120 times_fed: 1 Notice how we have only updated the instance variables but not the class variables related to the (located in the rectangle). The new methods in the Animal class were already defined before, I added them in the image above for clarity reasons - (it shows where the function comes from).\n"},{"id":18,"href":"/cs61a/docs/week-4/recursion/","title":"Recursion","section":"Week 4","content":" Recursion # Recursive Functions # A function is recursive if the body of the function calls itself (either directly or indirectly).\nRecursive functions pretty much always lead to a base case by operating on increasingly smaller instances of the problem. A base case is the simplest case possible where a calculation can actually be done.\nFor example, a recursive function to sum the digits in a number can be written as below:\ndef sum_digits(n): assert n \u0026gt;= 0 if n \u0026lt; 10: # Base case, only happens when there\u0026#39;s 1 remaining digit return n return sum_digits(n // 10) + n % 10 # Adds the rest of the number with the final number # sum_digits(n // 10) just calls the sum_digits function again but with a simpler case in this case. Another example is a factorial function:\ndef factorial(n): assert n \u0026gt;= 0 if n == 1 or n == 0: return 1 else: return n * factorial(n - 1) If you notice how factorial works, it repeatedly multiplies n with a value one lower than itself, which allows the recursive function above to work.\nAs a result, the anatomy of a recursive function can be broken down into the following components:\nBase Case: The smallest sub-problem Recursive Case: Breaking down a problem into a smaller sub-problem Conditional Statement: Decides whether something is a base case or a recursive case. Recursion in Environment Diagrams # If we use the same factorial function from above, calling factorial(3) on it, we can visualize the function calls in the environment diagram below in two steps — first reaching the base case, then evaluating the result.\nGlobal Frame f1: factorial(x) [parent = Global] f2: factorial(x) [parent = Global] f3: factorial(x) [parent = Global] func factorial(n) [parent = Global] factorial 3 n 3 * (factorial(2)) Return Value 2 n 2 * (factorial(1)) Return Value 1 n 1 Return Value After the base case is reached, each return value in the stack can be evaluated:\nGlobal Frame f1: factorial(x) [parent = Global] f2: factorial(x) [parent = Global] f3: factorial(x) [parent = Global] func factorial(n) [parent = Global] factorial 3 n 3 * 2 = 6 Return Value 2 n 2 * 1 = 2 Return Value 1 n 1 Return Value As a result, we can visualize a recursive call almost like that of a stack. The values keep reducing to a simpler case until a base case is reached, and when that happens, the result for each recursive call (starting from the base case) is then evaluated, which then will combine to evaluate to the final result.\nVerifying Recursive Functions # Domino Example # Let\u0026rsquo;s use an example to illustrate how designing/verifying a recursive function can work.\nTake for example that you had a line of a thousand equally spaced dominoes, and you wanted to test whether tipping one would tip all of them, you could just see if 1 domino would fall if tipped, then assume that any domino will tip the next one, then verify that tipping the first domino tips the next one.\nThis can be generalized with two different methods:\nRecursive Leap of Faith # Steps:\nVerify the base case — make sure it\u0026rsquo;s functional and works properly Assume that a simplified case of the function is correct (← leap of faith) Verify that the function itself returns the simplified function calls correctly For a more concrete example, take the factorial function from above:\nVerify that return 1 if n == 0 or n == 1 is the correct base case Assume that factorial(n - 1) returns the correct value Verify that n * factorial(n - 1) is the correct statement Recursive Cat\u0026rsquo;s Promise # While this usually isn\u0026rsquo;t a cat\u0026rsquo;s promise, but rather an elf, I like cats, so I\u0026rsquo;m going to go with cats.\nWith this perspective, the recursive cat handles the simplified recursive call, and promises that they will calculate the smaller recursive call for you while you handle the rest.\nFor example, to calculate 3!, you would ask yourself how you could calculate 3! if you knew the value of 2!, which in this case, is simply 3 * 2! — as a result, you do! Then, the recursive cat promises to handle the result of factorial(2) for you. (The recursive cat then calls on itself to find the value of factorial(1), but you do not need to know that to be able to solve factorial(5) — all you need is the value of factorial(4))\nMutual Recursion # When recursive functions are defined in terms of each other, the functions are mutually recursive.\nFor example, we can have this (useless) function that determines whether a number is even or odd in a mutually recursive manner:\ndef even(n): if n == 0: return True else: return odd(n - 1) def odd(n): if n == 0: return False else: return even(n - 1) print(even(4)) # True Note: Mutually recursive functions can be written as a single recursive function by simply breaking the abstraction boundary between the two functions. For example, the code above can be written in the following manner:\ndef even(n): if n == 0: return True else: if (n - 1) == 0: return False return even((n - 1) - 1) As you can see, the code checks whether a number is even initially, then checks for the odd case and thus, deals with 2 digits in 1 go. However, this implementation is far more convoluted than the mutually recursive version (and you can imagine how much more complex this would be with more complexity), so using a mutually recursive solution can simply be a mechanism for keeping your code simple; in other words: maintaining abstraction.\nA good indicator of when a mutual recursive solution could be used is when there is a natural recursive solution, but there is more than 1 case that needs to be checked for (in the above example, whether the number was even or odd)\nRecursion + Iteration # Converting Recursion to Iteration # First, you must figure out what state needs to be maintained by the iterative function that the recursive function would store itself. For example, in the factorial function, the recursive function works by multiplying n with a simpler version of the factorial function, meaning that the iterative version would need something to store n and multiply it with n - 1 until a \u0026lsquo;base case\u0026rsquo; is reached.\nFor instance:\ndef recursive_factorial(n): assert n \u0026gt;= 0 if n == 1 or n == 0: return 1 else: return n * recursive_factorial(n - 1) def iterative_factorial(n): k = n - 1 while k \u0026gt; 0: # \u0026#39;Base Case\u0026#39; n = n * k # Does the multiplication k = k - 1 # Decrements n, similar to recursive_factorial(n - 1) return k Converting Iteration to Recursion # Converting iteration to recursion is sometimes easier than doing it the other way around. Essentially, the state of an iteration can be passed in as arguments to the recursive function:\ndef iterative_sum_digits(n): total = 0 while n \u0026gt;= 10: digit_sum = digit_sum + n % 10 # n = n // 10 return total def recursive_sum_digits(n, total): if n \u0026lt; 10: return n else: return(n // 10, total + n % 10) # Iterative variables passed as arguments for the recursive version Helper Functions # If a recursive function ever needs to keep track of more variables than the original function provides, you probably need a helper function for that.\ndef is_prime(n): \u0026#39;\u0026#39;\u0026#39;Returns True if n is a prime number, else returns False \u0026gt;\u0026gt;\u0026gt; is_prime(13) True \u0026gt;\u0026gt;\u0026gt; is_prime(14) False \u0026gt;\u0026gt;\u0026gt; is_prime(2) True \u0026#39;\u0026#39;\u0026#39; assert n \u0026gt;= 2 def helper(i): if i == n: return True elif n % i == 0: return False else: return helper(i + 1) return helper(2) "},{"id":19,"href":"/cs61a/docs/week-8/recursive-data/","title":"Recursive Data","section":"Week 8","content":" Recursive Data # Linked Lists # Python lists are implemented in a way that makes inserting and deleting from the front of a list very inefficient. This is because Python implemented a list such that the first element of the list is always at the same memory location and elements in a list are located right next to each other, so when something is inserted to the start, everything gets pushed forward by one space in memory to make space for an element.\nIf you ever need to constantly add to the front of a list, a Python list may not be a good idea. That\u0026rsquo;s where a Linked List can come in handy.\nImagine building a list where each element can be anywhere in memory, and all that needs to happen is that one element knows where the next is:\nI drew each node (or element) in a different location on the page just to illustrate that these blocks could be anywhere on the page and do not need to be directly next to each other like in a list. Each instance/element/node of our linked list just needs a value inside it, and an arrow pointing to the next linked list object. If we think of it this way, we can construct our own Linked List class.\nclass Link: empty = () # How we will refer to an empty linked list def __init__(self, first, rest = empty): self.first = first self.rest = rest Using this class, we can then define our first linked list!\nmy_link = Link(1, Link(2), Link(3)) # Notice how similar it is to the tree data abstraction you used earlier In the example above, 1 is what gets stored in self.first, while Link(2, Link(3)) is what gets stored in self.rest, meaning that we are able to continue accessing our linked list.\nHowever, one thing is pretty clear: it\u0026rsquo;s impossible to directly access our Link(3) instance without first going through our whole list, following the list of pointers right until the end. This is one of the downsides of using a linked list in comparison to a python list - there are both benefits and drawbacks.\nLink Class # A fancier version of the linked list that CS61A uses is the following:\nclass Link: \u0026#34;\u0026#34;\u0026#34;A linked list.\u0026#34;\u0026#34;\u0026#34; empty = () def __init__(self, first, rest=empty): assert rest is Link.empty or isinstance(rest, Link) # makes sure that the rest is either a linked list or emtpy self.first = first self.rest = rest def __repr__(self): if self.rest: rest_repr = \u0026#39;, \u0026#39; + repr(self.rest) else: rest_repr = \u0026#39;\u0026#39; return \u0026#39;Link(\u0026#39; + repr(self.first) + rest_repr + \u0026#39;)\u0026#39; # Returns the link class def __str__(self): string = \u0026#39;\u0026lt;\u0026#39; while self.rest is not Link.empty: string += str(self.first) + \u0026#39; \u0026#39; # Recursion!!! self = self.rest return string + str(self.first) + \u0026#39;\u0026gt;\u0026#39; Using this structure can make us certain that a Link instance is only able to point to either another instance of Link or Link.empty.\nExercise: Creating a Range in a Linked List format # Let\u0026rsquo;s try to create something equivalent to [x for x in range(3, 6)] but in a linked list rather than a pythonic list.\ndef range_link(start, end): if start \u0026gt;= end: return Link.empty # base case else: return Link(start, range_link(start + 1, end)) # Recursive case to link the lists together Exercise: Making a map function for a Linked List # Making a copy # def map_ll(fn, ll): if ll is Link.empty: return Link.empty return Link(fn(ll.first), map_ll(fn, ll.rest)) Mutating the list given # We can mutate the list because it\u0026rsquo;s stored in a class, and as you know from making your classes, it is possible to mutate your instance variables (which is what appears here) which is why these solutions may feel weird initially.\ndef map_ll(fn, ll): while ll is not Link.empty: ll.first = fn(ll.first) # direct mutation of the linked list ll = ll.rest # move forward in the linked list Exercise: Filter # def filter_ll(fn, ll): if ll is Link.empty: return Link.empty elif fn(ll.first): return Link(ll.first, filter_ll(fn, ll.rest)) else: return filter_ll(fn, ll.rest) # moves onto the next case General Mutation caveats # You can sometimes have infinite linked lists if you set the rest instance variable to point to itself.\nmy_ll = Link(3) my_ll.rest = my_ll What this will do is point the linked list to itself, so when you try to do a recursive solution on it, it will never find a case where my_ll.rest is Link.empty.\nInserting to the Linked List # If you look at the image above, it outlines the process of inserting into the middle of a linked list in a visual manner.\ndef insert_ll(ll, val, position): if ll is Link.empty: assert False, \u0026#34;Position not found in Linked List\u0026#34; if position == 0: new_link = Link(val) new_link.rest = ll.rest ll.rest = new_link else: insert_ll(ll.rest, val, position - 1) Tree Class # Remember the tree we made as a data abstraction? One issue that we had with the original implementation is that we couldn\u0026rsquo;t mutate our tree label. However, because of the properties of classes, we are able to do that with a new implementation of our tree:\nclass Tree: def __init__(self, label, branches=[]): self.label = label self.branches = list(branches) def is_leaf(self): return not self.branches This will let us directly change self.label.\nCS61A uses this:\nclass Tree: def __init__(self, label, branches=[]): self.label = label for branch in branches: assert isinstance(branch, Tree) self.branches = list(branches) def is_leaf(self): return not self.branches def __repr__(self): if self.branches: branch_str = \u0026#39;, \u0026#39; + repr(self.branches) else: branch_str = \u0026#39;\u0026#39; return \u0026#39;Tree({0}{1})\u0026#39;.format(self.label, branch_str) def __str__(self): return \u0026#39;\\n\u0026#39;.join(self.indented()) def indented(self): lines = [] for b in self.branches: for line in b.indented(): lines.append(\u0026#39; \u0026#39; + line) return [str(self.label)] + lines Tree Mutation # Exercise: Double every label of a tree # Let\u0026rsquo;s try to double every label of a tree by mutating every value:\ndef double(t): t.label = t.label * 2 for b in t.branches: double(b) Exercise: Prune Trees # Removing subtrees from a tree is called pruning. When you do this, always prune before doing the recursive call.\ndef prune(t, n): \u0026#34;\u0026#34;\u0026#34;Prune all subtrees with label n\u0026#34;\u0026#34;\u0026#34; t.branches = [b for b in t.branches if b.label != n] for b in t.branches: prune(b, n) "},{"id":20,"href":"/cs61a/docs/week-11/scheme-lists/","title":"Scheme Lists","section":"Week 11","content":" Scheme Lists # Special Forms # Cond \u0026amp; Begin # The cond special form behaves like if-elif-else statements in Python:\nif x \u0026gt; 10: print(\u0026#39;big\u0026#39;) elif x \u0026gt; 5: print(\u0026#39;medium\u0026#39;) else: print(\u0026#39;small\u0026#39;) In Scheme:\n(cond ((\u0026gt; x 10) (print \u0026#39;big)) ((\u0026gt; x 5) (print \u0026#39;medium)) (else (print \u0026#39;small))) (cond ((\u0026gt; x 10) \u0026#39;big) ((\u0026gt; x 5) \u0026#39;medium) (else \u0026#39;small)) The begin special form combines multiple expressions into one expression:\nif x \u0026gt; 10: print(\u0026#39;big\u0026#39;) print(\u0026#39;guy\u0026#39;) else: print(\u0026#39;small\u0026#39;) print(\u0026#39;fry\u0026#39;) In Scheme:\n(cond ((\u0026gt; x 10) (begin (print \u0026#39;big) (print \u0026#39;guy))) (else (begin (print \u0026#39;small) (print \u0026#39;fry)))) (if (\u0026gt; x 10) (begin (print \u0026#39;big) (print \u0026#39;guy)) (begin (print \u0026#39;small) (print \u0026#39;fry))) Let Expressions # The let special form binds symbols to values temporarily; just for one expression:\na = 3 b = 2 + 2 c = math.sqrt(a * a + b * b) # a and b are still bound down here In Scheme:\n(define c (let ((a 3) (b (+ 2 2))) (sqrt (+ (* a a) (* b b))))) # a and b are not bound down here Turtle Graphics # Drawing Stars # Basic turtle commands:\n(forward 100) or (fd 100) draws a line (right 90) or (rt 90) turns 90 degrees Example of drawing a star:\n(define (star n m) (let ((a (/ (* 360 m) n))) (define (side k) (if (\u0026lt; k n) (begin (fd 100) (rt a) (side (+ k 1))))) (side 0))) Scheme Lists # In the late 1950s, computer scientists used some confusing names for list operations:\ncons: Two-argument procedure that creates a linked list car: Procedure that returns the first element of a list cdr: Procedure that returns the rest of a list nil: The empty list Important! Scheme lists are written in parentheses with elements separated by spaces:\n\u0026gt; (cons 1 (cons 2 nil)) (1 2) \u0026gt; (define x (cons 1 (cons 2 nil))) \u0026gt; x (1 2) \u0026gt; (car x) 1 \u0026gt; (cdr x) (2) \u0026gt; (cons 1 (cons 2 (cons 3 (cons 4 nil)))) (1 2 3 4) List Construction # There are three main ways to construct lists:\ncons: Always called on two arguments - a first value and the rest of the list list: Called on any number of arguments that all become values in a list append: Called on any number of list arguments that all become concatenated in a list Examples:\nscm\u0026gt; (define s (cons 1 (cons 2 nil))) scm\u0026gt; (list 3 s) (3 (1 2)) scm\u0026gt; (cons 3 s) (3 1 2) scm\u0026gt; (append s s) (1 2 1 2) Recursive Construction # To build a list one element at a time, use cons. To build a list with a fixed length, use list.\nExample of splitting a list:\n;;; Return a list of two lists; the first n elements of s and the rest ;;; scm\u0026gt; (split (list 3 4 5 6 7 8) 3) ;;; ((3 4 5) (6 7 8)) (define (split s n) (if (= n 0) (list nil s) (let ((split-rest (split (cdr s) (- n 1)))) (cons (cons (car s) (car split-rest)) (cdr split-rest))))) Symbolic Programming # Symbols normally refer to values, but we can refer to symbols directly using quotation:\n\u0026gt; (define a 1) \u0026gt; (define b 2) \u0026gt; (list a b) (1 2) \u0026gt; (list \u0026#39;a \u0026#39;b) (a b) \u0026gt; (list \u0026#39;a b) (a 2) Quotation can also be applied to combinations to form lists:\n\u0026gt; \u0026#39;(a b c) (a b c) \u0026gt; (car \u0026#39;(a b c)) a \u0026gt; (cdr \u0026#39;(a b c)) (b c) List Processing # Built-in List Processing Procedures # (append s t): List the elements of s and t; append can be called on more than 2 lists (map f s): Call a procedure f on each element of a list s and list the results (filter f s): Call a procedure f on each element of a list s and list the elements for which a true value is the result (apply f s): Call a procedure f with the elements of a list s as its arguments Example:\n(define count (list 1 2 3 4)) (define beats (map (lambda (x) (list \u0026#39;and \u0026#39;a x)) count)) (define rhythm (apply append beats)) "},{"id":21,"href":"/cs61a/docs/week-11/scheme/","title":"Scheme Specification","section":"Week 11","content":" Scheme Specification # This document describes the variant of Scheme used in CS61A, which is closest to R5RS with some modifications for educational purposes.\nOverview and Terminology # Expressions and Environments # Every expression evaluates to a value Some expressions are self-evaluating (numbers, booleans, strings, nil) Frames map symbols to values with optional parent frames Environment lookup follows the chain of parent frames Atomic Expressions # Numbers, booleans, strings, and nil are self-evaluating Symbols evaluate to their bound values in the environment Call Expressions # Most combinations are evaluated as call expressions with three steps:\nEvaluate the operator (must be a procedure) Evaluate the operands in order Apply the procedure to the evaluated arguments Special Forms # Special forms have their own evaluation rules and are identified by keywords:\n(if \u0026lt;predicate\u0026gt; \u0026lt;consequent\u0026gt; [alternative]) (cond \u0026lt;clause\u0026gt; ...) (and [test] ...) (or [test] ...) (let ([binding] ...) \u0026lt;body\u0026gt; ...) (begin \u0026lt;expression\u0026gt; ...) (lambda ([param] ...) \u0026lt;body\u0026gt; ...) (quote \u0026lt;expression\u0026gt;) (quasiquote \u0026lt;expression\u0026gt;) (mu ([param] ...) \u0026lt;body\u0026gt; ...) (define-macro (\u0026lt;name\u0026gt; [param] ...) \u0026lt;body\u0026gt; ...) Types of Values # Numbers # Built on Python\u0026rsquo;s number types Supports arbitrarily-large integers and double-precision floats Case-insensitive (except in strings) Booleans # Two values: #t and #f Can be input as true or false Only #f is false in boolean contexts Symbols # Used as identifiers Valid characters: alphanumeric and !$%\u0026amp;*/:\u0026lt;=\u0026gt;?@^_~+-. Stored internally in lowercase Cannot form valid numbers Strings # Atomic data type (no individual characters) Immutable Entered as characters inside double quotes Limited string manipulation support Pairs and Lists # Pairs have car and cdr fields Lists are either nil or pairs with list cdr Streams use promises in their cdr List literals can be constructed with quote Procedures # First-class values Types: Built-in procedures Lambda procedures Mu procedures Macro procedures Promises and Streams # Promises represent delayed evaluation Created with delay Evaluated with force Streams are pairs with promise cdr Special forms: cons-stream, cdr-stream Special Forms in Detail # define # (define \u0026lt;name\u0026gt; \u0026lt;expression\u0026gt;) (define (\u0026lt;name\u0026gt; [param] ...) \u0026lt;body\u0026gt; ...) Binds values or creates procedures in the current environment.\nif # (if \u0026lt;predicate\u0026gt; \u0026lt;consequent\u0026gt; [alternative]) Conditional evaluation based on predicate.\ncond # (cond \u0026lt;clause\u0026gt; ...) Multiple condition evaluation with optional else clause.\nlet # (let ([binding] ...) \u0026lt;body\u0026gt; ...) Creates new frame with bindings for body evaluation.\nbegin # (begin \u0026lt;expression\u0026gt; ...) Evaluates expressions in sequence, returns last value.\nlambda # (lambda ([param] ...) \u0026lt;body\u0026gt; ...) Creates procedure with lexical scoping.\nquote # (quote \u0026lt;expression\u0026gt;) \u0026#39;\u0026lt;expression\u0026gt; Returns unevaluated expression.\nquasiquote # (quasiquote \u0026lt;expression\u0026gt;) `\u0026lt;expression\u0026gt; Returns unevaluated expression with selective evaluation.\nmu # (mu ([param] ...) \u0026lt;body\u0026gt; ...) Creates procedure with dynamic scoping.\ndefine-macro # (define-macro (\u0026lt;name\u0026gt; [param] ...) \u0026lt;body\u0026gt; ...) Creates macro procedure for defining new special forms.\nBest Practices # Use proper scoping\nLambda for lexical scoping Mu for dynamic scoping Macros for new special forms Handle promises carefully\nOnly force once Check for proper return types Handle errors appropriately Use appropriate data structures\nLists for sequential data Streams for infinite sequences Pairs for binary relationships Follow evaluation rules\nUnderstand special forms Know when expressions are evaluated Use quote appropriately Write clear code\nUse meaningful names Comment complex logic Format consistently "},{"id":22,"href":"/cs61a/docs/week-5/sequences/","title":"Sequences","section":"Week 5","content":" Sequences # Lists in Environment Diagrams # Lists can represented with box and pointer notation (similarly to functions); however, unlike functions, each element in the array has its own box, and is index labelled.\nWhat this implies is that assigning a variable to another list will not create a copy of that list, but rather point towards the same list — this ends up being a correct assumption to make.\nEach box can either hold a value (for example a number or a string), or an object (for example, a function, another list, or a Class).\nList Slicing # Slicing a list creates a new list (as in it points to a separate list). The behaviour is very similar to the range() function — it starts on the first \u0026lsquo;argument\u0026rsquo; provided, ends on the number right before the second \u0026lsquo;argument\u0026rsquo;, with step of the third \u0026lsquo;argument\u0026rsquo;. In this case however, the separator is : rather than ,. If there is no argument provided next to the :, it defaults to 0.\nThe syntax is lst[\u0026lt;start\u0026gt;:\u0026lt;end\u0026gt;:\u0026lt;step_size\u0026gt;]\nBelow are some examples:\nlst = [1, 2, \u0026#34;bananas\u0026#34;] lst[0:] # [1, 2, \u0026#34;bananas\u0026#34;] lst[:2] # [1, 2] lst[1:] # [2, \u0026#34;bananas\u0026#34;] lst[::2] # [1, \u0026#34;bananas\u0026#34;] This behaviour also works with strings:\nstring = \u0026#34;benbaron\u0026#34; string[3:] # \u0026#34;baron\u0026#34; string[:3] # \u0026#34;ben\u0026#34; Small Practice Problems # Recursion in Lists # Imagine summing the numbers in a list but using recursion rather than iteration or the sum() function.\ndef sum_numbers(lst): \u0026#39;\u0026#39;\u0026#39;Returns the sum of the numbers in lst \u0026gt;\u0026gt;\u0026gt; sum_numbers([2, 3, 4]) 9 \u0026#39;\u0026#39;\u0026#39; We could implement the function above using list comprehension:\ndef sum_numbers(lst): \u0026#39;\u0026#39;\u0026#39;Returns the sum of the numbers in lst \u0026gt;\u0026gt;\u0026gt; sum_numbers([2, 3, 4]) 9 \u0026#39;\u0026#39;\u0026#39; if lst == []: # base case return 0 else: return lst[0] + sum_numbers(lst[1:]) # takes the first number and # recursively calls the function on a smaller list. Reversing a String (Recursively) # def reverse_string(word): \u0026#39;\u0026#39;\u0026#39;Reverse the string provided in word \u0026gt;\u0026gt;\u0026gt; reverse_string(\u0026#34;ben\u0026#34;) neb \u0026#39;\u0026#39;\u0026#39; Our base case here would be when the word provided is an empty string.\ndef reverse_string(word): \u0026#39;\u0026#39;\u0026#39;Reverse the string provided in word \u0026gt;\u0026gt;\u0026gt; reverse_string(\u0026#34;ben\u0026#34;) neb \u0026#39;\u0026#39;\u0026#39; if word == \u0026#34;\u0026#34;: return \u0026#34;\u0026#34; else: return reverse_string(word[1:]) + word[0] # keep in mind the order of the operation above matters # word[0] is put afterwards because # that should be added up later Built-in functions for Iterables # Function Description sum(iterable, start) Returns the sum of the values in iterable, with a starting sum of start (defaults to 0) all(iterable) Returns True if all the values of iterable are Truthy values (or if the iterable is empty), else returns False any(iterable) Returns True if any of the values of iterable are Truthy, else returns False max(iterable, key=None) Returns the maximum value in iterable min(iterable, key=None) Returns the minimum value in iterable Examples of the built-in functions # sum([3, 2, 1], 50) # 56 any([True, False, False, False]) # True any([3, 2, 1, 0]) # True all([3, 2, 1]) # True all([True, False, False, False]) # False max([3, 2, 1]) # 3 max([\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;]) # \u0026#34;c\u0026#34; max(range(10)) # 9 # the \u0026#39;key\u0026#39; parameter can be used to compare certain elements in an array: coords = [[1, 2], [4, 3], [3, 90]] max(coords, key = lambda x: x[0]) # [4, 3] (x iterates through coords and then checks the max value of the first element) "},{"id":23,"href":"/cs61a/docs/week-13/sql-intro/","title":"SQL","section":"Week 13","content":" Introduction to SQL # SQL (Structured Query Language) is a powerful language used for managing and manipulating relational databases. It allows us to create, read, update, and delete data in a structured way.\nBasic Concepts # Tables # Tables are the fundamental structure in SQL databases. They consist of:\nColumns (attributes) Rows (records) Primary keys (unique identifiers) Example table structure:\nCREATE TABLE students ( id INTEGER PRIMARY KEY, name TEXT NOT NULL, major TEXT, gpa FLOAT ); Basic Operations # SELECT # The most common operation to retrieve data:\n-- Select all columns SELECT * FROM students; -- Select specific columns SELECT name, major FROM students; -- Select with conditions SELECT * FROM students WHERE gpa \u0026gt; 3.5; INSERT # Adding new records:\n-- Insert a single record INSERT INTO students (name, major, gpa) VALUES (\u0026#39;John Doe\u0026#39;, \u0026#39;Computer Science\u0026#39;, 3.8); -- Insert multiple records INSERT INTO students (name, major, gpa) VALUES (\u0026#39;Jane Smith\u0026#39;, \u0026#39;Mathematics\u0026#39;, 3.9), (\u0026#39;Bob Johnson\u0026#39;, \u0026#39;Physics\u0026#39;, 3.7); UPDATE # Modifying existing records:\n-- Update a single record UPDATE students SET gpa = 3.9 WHERE name = \u0026#39;John Doe\u0026#39;; -- Update multiple records UPDATE students SET major = \u0026#39;Computer Science\u0026#39; WHERE major = \u0026#39;CS\u0026#39;; DELETE # Removing records:\n-- Delete specific records DELETE FROM students WHERE gpa \u0026lt; 2.0; -- Delete all records DELETE FROM students; Advanced Queries # Joins # Combining data from multiple tables:\n-- Inner join SELECT students.name, courses.name FROM students JOIN enrollments ON students.id = enrollments.student_id JOIN courses ON enrollments.course_id = courses.id; ### Aggregation Performing calculations on groups of data: ```sql -- Count SELECT COUNT(*) FROM students; -- Average SELECT AVG(gpa) FROM students; -- Group by SELECT major, AVG(gpa) FROM students GROUP BY major; Subqueries # Queries within queries:\n-- Find students with above-average GPA SELECT name, gpa FROM students WHERE gpa \u0026gt; (SELECT AVG(gpa) FROM students); Best Practices # Use meaningful table and column names\nBe descriptive and consistent Use underscores for spaces Avoid reserved words Always specify columns in INSERT statements\n-- Good INSERT INTO students (name, major) VALUES (\u0026#39;John\u0026#39;, \u0026#39;CS\u0026#39;); -- Bad INSERT INTO students VALUES (\u0026#39;John\u0026#39;, \u0026#39;CS\u0026#39;); Use appropriate data types\nINTEGER for whole numbers FLOAT for decimal numbers TEXT for strings BOOLEAN for true/false values Include WHERE clauses in UPDATE and DELETE\nPrevents accidental updates/deletes Always test with SELECT first Use transactions for multiple operations\nBEGIN TRANSACTION; UPDATE accounts SET balance = balance - 100 WHERE id = 1; UPDATE accounts SET balance = balance + 100 WHERE id = 2; COMMIT; Common Pitfalls # Forgetting WHERE clauses\nCan lead to updating/deleting all records Always double-check conditions Not using indexes\nCan cause slow queries on large tables Add indexes on frequently searched columns **Overusing SELECT ***\nOnly select needed columns Improves performance and clarity Ignoring NULL values\nNULL is not the same as 0 or empty string Use IS NULL or IS NOT NULL for comparisons Example Database Schema # -- Students table CREATE TABLE students ( id INTEGER PRIMARY KEY, name TEXT NOT NULL, major TEXT, gpa FLOAT ); -- Courses table CREATE TABLE courses ( id INTEGER PRIMARY KEY, name TEXT NOT NULL, department TEXT, credits INTEGER ); -- Enrollments table (junction table) CREATE TABLE enrollments ( student_id INTEGER, course_id INTEGER, grade TEXT, FOREIGN KEY (student_id) REFERENCES students(id), FOREIGN KEY (course_id) REFERENCES courses(id) ); This schema demonstrates:\nPrimary keys Foreign keys Many-to-many relationships Appropriate data types Table relationships "},{"id":24,"href":"/cs61a/docs/week-8/representation/","title":"String Interpolation and Representation","section":"Week 8","content":" String Interpolation and Representation # String Interpolation # This is not part of representation, but is instead an extremely useful tool to make writing strings with multiple variables far cleaner. You may have already seen me use string interpolation earlier on in the course.\nIn Python, the cleanest way to use string interpolation is with an f-string, where the letter f is appended before quotation marks.\nf\u0026#34;\u0026#34; You can see the syntax highlighting sees the f in a different colour! With this notation, we can then put expressions in our string itself and have them evaluate to \u0026lsquo;proper\u0026rsquo; values. Different languages deal with string interpolation in different manners.\none = 1 two = \u0026#34;two\u0026#34; five = \u0026#34;five\u0026#34; f\u0026#34;{one + 1} {two}, {five}\u0026#34; # will return \u0026#34;2 two, five\u0026#34; Representation # Built-in Object Attributes # In Python, every built in type inherits from object. Everything in Python is an object of some sort. As a result, they all have their own dunder methods that are different for every object.\nIf you run dir() on an object (which could be a string, list, or something else), you will see a list of its methods. Behind the scenes, Python runs these dunder methods, so we don\u0026rsquo;t really need to worry about those (kind of like data abstraction if you think about it)\nString Representation # The __str__ method returns a string representation made to be human readable.\nThe use of this method is most likely better with a concrete example, so let\u0026rsquo;s define our own class for Rational numbers (similarly to the data abstraction we were using earlier).\nfrom math import gcd class Rational: def __init__(self, numerator: int, denominator: int): g = gcd(numerator, denominator) self.numerator = numerator // g self.denominator = denominator // g So far, if we make an instance of the class and then print that instance, we get a non-useful output:\n\u0026gt;\u0026gt;\u0026gt; my_rational = Rational(2, 3) \u0026gt;\u0026gt;\u0026gt; print(my_rational) \u0026lt;__main__.Rational object\u0026gt; When we define our own __str__ method, calling print() on the instance will look for the __str__ method and return the value. However, the print method removes quotes, while calling str() on the same thing will not remove quotes (an example will be given in the doctests).\nclass Rational: \u0026#34;\u0026#34;\u0026#34; \u0026gt;\u0026gt;\u0026gt; my_rational = Rational(2, 3) \u0026gt;\u0026gt;\u0026gt; print(my_rational) 2 / 3 \u0026gt;\u0026gt;\u0026gt; str(my_rational) \u0026#39;2 / 3\u0026#39; \u0026#34;\u0026#34;\u0026#34; def __init__(self, numerator: int, denominator: int): g = gcd(numerator, denominator) self.numerator = numerator // g self.denominator = denominator // g def __str__(self): return f\u0026#34;{self.numerator} / {self.denominator}\u0026#34; # We define how our class will look in the console here Machine Representation # On the other hand, the __repr__ method is used to return a string that would evaluate to an object with the same values (in a traditional sense - when you override the __repr__ method, you can set it to anything you want)\nThe goal is to make it such that when you call eval() on the result, it should return the same valued object (but not the same pointer).\nclass Rational: \u0026#34;\u0026#34;\u0026#34; \u0026gt;\u0026gt;\u0026gt; my_rational = Rational(2, 3) \u0026gt;\u0026gt;\u0026gt; my_rational Rational(2, 3) \u0026gt;\u0026gt;\u0026gt; eval(Rational.__repr__(my_rational)) Rational(2, 3) \u0026gt;\u0026gt;\u0026gt; repr(my_rational) \u0026#39;Rational(2, 3)\u0026#39; \u0026#34;\u0026#34;\u0026#34; def __init__(self, numerator: int, denominator: int): g = gcd(numerator, denominator) self.numerator = numerator // g self.denominator = denominator // g def __str__(self): return f\u0026#34;{self.numerator} / {self.denominator}\u0026#34; def __repr__(self): return f\u0026#34;Rational({self.numerator}, {self.denominator})\u0026#34; Notice how calling repr(my_rational) returned what you would expect but in quotation marks.\nImplicit calling of print() # Type Methods of Calling Implicitly calls print() Directly calling in interactive environment; print() Does not implicitly call print() repr(), str() Doing print(\u0026ldquo;Ben\u0026rdquo;) to the console will output Ben (without the quote marks). In other words, calling print() on something removes a set of quote marks. However, calling str(\u0026ldquo;Ben\u0026rdquo;) in the console will output \u0026lsquo;Ben\u0026rsquo; instead, suggesting that it doesn\u0026rsquo;t call print() to remove the set of quotes. If we directly output something to the console, it first calls repr() on it, then prints it to the console. So overall, when we just call something, it does the equivalent of print(repr(\u0026ldquo;Ben\u0026rdquo;)), which is the same as print(\u0026quot;\u0026lsquo;Ben\u0026rsquo;\u0026quot;), which will remove the outside set of quotes and then return \u0026lsquo;Ben\u0026rsquo; to the console.\nprint(\u0026#34;Ben\u0026#34;) # Ben \u0026#34;Ben\u0026#34; # \u0026#39;Ben\u0026#39; (comes from print(repr(\u0026#34;Ben\u0026#34;))) repr(\u0026#34;Ben\u0026#34;) # \u0026#34;\u0026#39;Ben\u0026#39;\u0026#34; str(\u0026#34;Ben\u0026#34;) # \u0026#39;Ben\u0026#39; Special Methods # There are other special dunder methods that map to built-in behaviour. For example, the __add__ method is called when two objects are added together:\n2 + 3 # is the same as 2.__add__(3) If we wanted to add two of our Rational classes together, it would error because there is currently no __add__ method defined. However, if we were to define our own __add__ method, we could make it such that Python would know how to deal with addition!\nclass Rational: def __init__(self, numerator: int, denominator: int): g = gcd(numerator, denominator) self.numerator = numerator // g self.denominator = denominator // g def __add__(self, other): assert isinstance(other, Rational) # Will require that the other thing passed in was a rational new_numerator = self.numerator * other.denominator + other.numerator * self.denominator new_denominator = self.denominator * other.denominator return Rational(new_numerator, new_denominator) def __str__(self): return f\u0026#34;{self.numerator} / {self.denominator}\u0026#34; def __repr__(self): return f\u0026#34;Rational({self.numerator}, {self.denominator})\u0026#34; This can be done for other methods like __mul__ - you just have to implement them yourselves.\nWeird behaviour of str and repr # repr() # Will ignore any instance variables created called __repr__. Only looks for this instance variable in the class.\nstr() # Will ignore any instance variables created called __str__. Only looks for this instance variable in the class.\nIf no __str__ is found (in the whole lookup order), it defaults to the first __repr__ it can find.\n"},{"id":25,"href":"/cs61a/docs/week-4/tree-recursion/","title":"Tree Recursion","section":"Week 4","content":" Tree Recursion # Order of Recursive Calls # If you know the behaviour of environment diagrams, you could derive the behaviour of recursive calls.\nRecaling how environment diagrams behave, a new frame is opened when a user-defined function call occurs, meaning that whenever a recursive function is called on a non-base case scenario, a new frame is opened, and that frame will be evaluated.\nAs a result, in a tree recursive return value (more on that later), for example recursive(3) + recursive(4), the whole value of recursive(3) is evaluated first before recursive(4) is evaluated (due to the order of operations of Python).\nTree Recursion # Tree recursion occurs when a recursive function makes more than one recursive call, thus creating a sort of network of sorts of recursive calls that is sort of shaped like the roots of a tree.\nFibonacci Numbers # def fib(n): if n \u0026lt;= 0: return 0 elif n == 1: return 1 return fib(n - 1) + fib(n - 2) fib(3) As you can see in the example above, the recursive call returns two instances of the same function, thus creating a structure that calls itself multiple times in a sort of tree-like fashion.\nNotice how this is pretty inefficient though! There are multiple calls to fib(1), so that function would need to be evaluated multiple times (and this redundant execution would get executed more if we started with fib(4) for instance). There are ways to alleviate this (to a certain extent), but we\u0026rsquo;ll cover that later.\nCounting Partitions # The solution to this classic tree recursion problem has a structure that can be used in other tree recursive problems — it\u0026rsquo;s worth truly understanding how it works.\nThe question is defined as follows:\nCount the number of possible partitions with positive integers n, using parts up to size m.\nThis problem has two distinct parts, one part calculating the possibilities with the current size m, and the other part calculating the possibilities with smaller part sizes m - 1 in a recursive manner.\nFor example, for count_partitions(4, 3), you could have the following outcomes:\n3 1 2 2 2 1 1 1 1 1 1 Which would return 4 as those are the total number of possibilities. Each line break represents a different path for the recursive solution.\nIn general, the recursive call can be generalized as follows count_partitions(n - m, m) + count_partitions(n, m - 1) which essentially is adding up the recursive function for the case where m is used, and the case where m is not used. After we have this logic, we just need to come up with the base cases, and assume that our recursive solution will work.\nFor our base cases, we know that if n is ever negative, there will be no possible results, and if m is equal to 0, it will not be possible to create any partitions of size n (other than 0). For n = 0, you can create 1 total partition by using partition size 0 (which is still less than m).\nAs a result, the code can be written as follows:\ndef count_partitions(n, m): if n == 0: return 1 elif n \u0026lt; 0 or m == 0: return 0 return count_partitions(n - m, m) + count_partitions(n, m - 1) "},{"id":26,"href":"/cs61a/docs/week-6/trees/","title":"Trees","section":"Week 6","content":" Trees # A tree is an abstract data structure (basically not implemented by default in Python), which means we need to use data abstractions in order to implement this structure.\nWhat does a tree look like? # A tree has a root and a list of branches, where each branch is a tree itself.\nA tree with zero branches (the white circles in the drawing above) is called a leaf. A tree also starts at the root, which in the drawing above, is the blue circle.\nWhile this may not look like a tree, but rather roots of the tree itself, you could potentially think of the drawing as an upside down tree.\nAlso notice how when we look at the branches stemming from the root, we have two separate sub-trees? This means that recursion will be a common way to go about solving tree-related problems.\nEach location in a tree can be called a node, and each node has a label which contains the value located within the node (can be any value). Nodes can be parents/children of each other, and the top node is the root node.\nTree Data Abstraction # There are many possible data abstraction for trees, but the one that CS61A uses is the following:\nAbstraction Description tree(label, branches = []) Returns a tree with root label and a list of branches label(tree) Returns the label of the tree branches(tree) Returns the branches of the tree (in a list) — each of which is a tree by itself is_leaf(tree) Returns True if the current node is a leaf node For example, a tree could be the following:\nt = tree(3, # Root Node # Branches: [tree(2, [tree(1)], # Left Branch tree(4))] # Right Branch ) The actual implementation of the tree is information that you do not need to know in order to use this data structure, so I will not write the implementation here. The documentation for these data abstractions says that branches(tree) returns a list, meaning that calling branches(tree)[0] is not a violation of data abstraction here.\nTree Processing # As mentioned earlier, tree problems are solved recursively. Let\u0026rsquo;s figure out why:\nEach tree has the following:\nA label 0 or more branches, with each branch containing a tree itself. Due to the fact that each branch contains a tree itself, this data type is recursive.\nExample Questions # Counting Leaves # If we wanted to count the number of leaves in a tree, how would we do that? Obviously, the solution has to be recursive, so we need to start with the recursive mindset:\nWhat is our base case? What is our recursive case? def count_leaves(t): \u0026#39;\u0026#39;\u0026#39;Returns the number of leaf nodes in tree t\u0026#39;\u0026#39;\u0026#39; if is_leaf(t): return 1 else: total_leaves = 0 for b in branches(t): total_leaves += count_leaves(b) return total_leaves In the code above, our base case happens when we hit a leaf, and the recursive call uses a for loop to go through all the branches in our tree, and then add the number of leaves to total_leaves, which is then returned.\nWe could also use the sum() function alongside a list comprehension to condense our code:\ndef count_leaves(t): \u0026#39;\u0026#39;\u0026#39;Returns the number of leaf nodes in tree t\u0026#39;\u0026#39;\u0026#39; if is_leaf(t): return 1 else: return sum([count_leaves(b) for b in branches(t)]) This works because the sum function can sum up the elements in an iterable.\nCreating Trees # A function that creates another tree based off of an existing tree is often recursive.\nLet\u0026rsquo;s recall how a tree is built:\nt = tree(3, # Root Node # Branches: [tree(2, [tree(1)], # Left Branch tree(4))] # Right Branch ) Let\u0026rsquo;s try and make a function that doubles each node in a tree:\ndef double(t): \u0026#39;\u0026#39;\u0026#39;Returns a tree with same structure as t, but with each node doubled\u0026#39;\u0026#39;\u0026#39; if is_leaf(t): return tree(label(t*2)) else: return tree(label(t*2), [double(b) for b in branches(t)]) Notice how we have repeated code? We can actually shorten the code to one line because of that (the base case here doesn\u0026rsquo;t need to be made explicit, will explain why later)\ndef double(t): \u0026#39;\u0026#39;\u0026#39;Returns a tree with same structure as t, but with each node doubled\u0026#39;\u0026#39;\u0026#39; return tree(label(t*2), [double(b) for b in branches(t)]) In the final code, we don\u0026rsquo;t need a base case/recursive case structure that you would traditionally see for recursive questions, but even so, it\u0026rsquo;s a good idea to think of it that way before condensing it down.\nThe code above works because in the case of a leaf node, [] gets passed into branches within the tree constructor, which by default takes in an empty list if there are no branches. Thus, in the case of a leaf node, all that gets returned there is equivalent of saying tree(label(t*2)).\nPrinting Trees # def print_tree(t, indent = 0): \u0026#39;\u0026#39;\u0026#39;Prints the labels of t with depth based indent\u0026#39;\u0026#39;\u0026#39; print(\u0026#34; \u0026#34; * indent + str(label(t))) for b in branches(t): print_tree(tree(b), indent + 1) Look at the example above and see how it works. indent + 1 is important as it will indent the tree to the correct level.\n"}]